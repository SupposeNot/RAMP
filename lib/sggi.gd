
# Basic constructors
DeclareGlobalVariable("UNIVERSAL_SGGI_FREE_GROUPS");

#! @Chapter Group Constructors
#! @Section Sggis

DeclareGlobalFunction("COXETER_GROUP_SIZES");

#! @BeginGroup UniversalSggi
#! @GroupTitle UniversalSggi

#! @Arguments n
#! @Returns `IsFpGroup`
#! @Description In the first form, returns the universal Coxeter Group of rank n.
DeclareOperation("UniversalSggi", [IsInt]);

#! @Arguments sym
#! In the second form, returns the Coxeter Group with Schlafli symbol sym.
DeclareOperation("UniversalSggi", [IsList]);
#! @BeginExampleSession
#! gap> g:=UniversalSggi(3);
#! <fp group of size infinity on the generators [ r0, r1, r2 ]>
#! gap> q:=UniversalSggi([3,4]);
#! <fp group of size 48 on the generators [ r0, r1, r2 ]>
#! gap> IsQuotient(g,q);
#! true
#! @EndExampleSession
#! @EndGroup


#! @BeginGroup Sggi
#! @GroupTitle Sggi

#! @Arguments symbol[, relations]
#! @Returns `IsFpGroup`
#! @Description Returns the sggi defined by the given Schlafli
#! symbol and with the given relations. The relations can be given
#! by a list of Tietze words or as a string of relators or relations
#! that involve r0 etc. If no relations are given, then returns
#! the universal sggi with the given Schlafli symbol.
#! This method automatically calls `InterpolatedString` on the relations, so
#! you may use \$variable in the relations, and it will be replaced with
#! the value of `variable` (but for global variables only).
#! @BeginExampleSession
#! gap> g := Sggi([4,3,4], "(r0 r1 r2)^3, (r1 r2 r3)^3");;
#! gap> h := Sggi([4,4], "r0 = r2");;
#! gap> k := Sggi([infinity, infinity], [[1,2,1,2,1,2], [2,3,2,3,2,3]]);;
#! gap> k = Sggi([3,3]);
#! true
#! gap> n := 3;;
#! gap> Size(Sggi([4,4], "(r0 r1 r2 r1)^$n"));
#! 72
#! @EndExampleSession
DeclareOperation("Sggi", [IsList, IsList]);

#! @Arguments sym, words, orders
#! @Returns `IsFpGroup`
#! @Description The second form takes the Schlafli Symbol <A>sym</A>, a list
#! of <A>words</A> in the generators r0 etc, and a list of <A>orders</A>.
#! It returns the reflexible maniplex that is the quotient of the universal
#! maniplex with that Schlalfi Symbol by the relations obtained by setting each
#! <A>word[i]</A> to have order <A>order[i]</A>. This is primarily useful for
#! quickly constructing a family of related Sggis.
DeclareOperation("Sggi", [IsList, IsList, IsList]);
#! @BeginExampleSession
#! gap> L := List([1..5], k -> Sggi([4,4], ["r0 r1 r2"], [2*k]));;
#! gap> List(L, Size);
#! [ 16, 64, 144, 256, 400 ]
#! @EndExampleSession
#! @EndGroup

#! @Arguments g
#! @Returns whether <A>g</A> is generated by involutions.
#! Or more specifically, whether GeneratorsOfGroup(<A>g</A>) all have
#! order 2 or less.
DeclareProperty("IsGgi", IsGroup);
#! @BeginExampleSession
#! gap> IsGgi(SymmetricGroup(4));
#! false
#! gap> IsGgi(Group([(1,2),(2,3)]));
#! true
#! @EndExampleSession

#! @Arguments g
#! @Returns whether every pair of non-adjacent generators of <A>g</A> commute.
DeclareProperty("IsStringy", IsGroup);
#! @BeginExampleSession
#! gap> IsStringy(Group((1,2),(2,3),(3,4)));
#! true
#! gap> IsStringy(Group((1,2),(3,4),(2,3)));
#! false
#! @EndExampleSession

#! @Arguments g
#! @Returns whether <A>g</A> is a string group generated by involutions.
#! Equivalent to `IsGgi(g) and IsStringy(g)`.
DeclareProperty("IsSggi", IsGroup);
#! @BeginExampleSession
#! gap> IsSggi(SymmetricGroup(4));
#! false
#! gap> IsSggi(Group((1,2),(3,4),(2,3)));
#! false
#! gap> IsSggi(Group((1,2),(2,3),(3,4)));
#! true
#! @EndExampleSession

#! @Arguments g
#! @Returns whether <A>g</A> is a string group generated by involutions such
#! that no generator and no product of two generators has any fixed points.
#! A premaniplex M is a maniplex if and only if IsFixedPointFreeSggi(ConnectionGroup(M)).
#! Equivalent to `IsGgi(g) and IsStringy(g)`.
DeclareProperty("IsFixedPointFreeSggi", IsGroup);
#! @BeginExampleSession
#! gap> IsFixedPointFreeSggi(Group((1,2)(3,4), (1,3)(2,4) ,(1,4)(2,3)));
#! true
#! gap> IsFixedPointFreeSggi(Group((1,2)(3,4), (1,2)(3,4), (1,4)(2,3)));
#! false
#! @EndExampleSession

#! @Arguments g
#! @Returns Whether <A>g</A> is a string rotation group, i.e. the even word subgroup
#! of an Sggi. This means that the product of adjacent generators should be an involution.
DeclareProperty("IsStringRotationGroup", IsGroup);
#! @BeginExampleSession
#! gap> IsStringRotationGroup(Group((1,2)(3,4), (2,3,4)));
#! false
#! gap> IsStringRotationGroup(Group((1,3,2), (2,4,3)));
#! true
#! @EndExampleSession

#! @Arguments G
#! @Returns Whether <A>G</A> is a string C group. Currently only works for finite groups.
DeclareProperty("IsStringC", IsGroup);
#! @BeginExampleSession
#! gap> IsStringC(Sggi([4,4], "r0 r1 r2"));
#! false
#! gap> IsStringC(Sggi([4,4], "(r0 r1 r2)^4"));
#! true
#! @EndExampleSession

#! @Arguments G
#! @Returns Whether <A>G</A> is a string C+ group. Currently only works for finite groups.
DeclareProperty("IsStringCPlus", IsGroup);
#! @BeginExampleSession
#! gap> IsStringCPlus(Group((1,2)(3,4), (2,3,4)));
#! false
#! gap> IsStringCPlus(Group((1,3,2), (2,4,3)));
#! true
#! gap> IsStringCPlus(RotationGroup(ToroidalMap44([1,0])));
#! false
#! @EndExampleSession

#! @Arguments g, str
#! @Returns the element of <A>g</A> with underlying word <A>str</A>.
#! @Description
#! This method automatically calls `InterpolatedString` on the relations, so
#! you may use \$variable in the relations, and it will be replaced with
#! the value of `variable` (but for global variables only).
#! @BeginExampleSession
#! gap> g := Group((1,2),(2,3),(3,4));;
#! gap> SggiElement(g, "r0 r1");
#! (1,3,2)
#! gap> n := 2;;
#! gap> SggiElement(g, "(r0 r1)^$n");
#! (1,2,3)
#! @EndExampleSession
#! For convenience, you can also use a reflexible maniplex M in place
#! of g, in which case `AutomorphismGroup(M)` is used for g.
DeclareOperation("SggiElement", [IsGroup, IsString]);

#! @Arguments g, str
#! @Returns the element of <A>g</A> with underlying word <A>str</A>, in a reduced form.
#! @Description This acts like SggiElement, except that the word is in reduced form.
#! Note that this is accomplished by calling SetReducedMultiplication on g. As a result,
#! further computations with g may be substantially slower.
#! This method automatically calls `InterpolatedString` on the relations, so
#! you may use \$variable in the relations, and it will be replaced with
#! the value of `variable` (but for global variables only).
#! For convenience, you can also use a reflexible maniplex M in place
#! of g, in which case `AutomorphismGroup(M)` is used for g.
DeclareOperation("SimplifiedSggiElement", [IsGroup, IsString]);
#! @BeginExampleSession
#! gap> g := AutomorphismGroup(Cube(3));;
#! gap> SimiplifiedSggiElement(g, "(r0 r1)^5");
#! r0*r1
#! @EndExampleSession


#! @Arguments M, rel
#! @Returns IsBool
#! @Description Determines whether the relation given by the string <A>rel</A> holds
#! in `AutomorphismGroup(M)`.
#! This method automatically calls `InterpolatedString` on the relations, so
#! you may use \$variable in the relations, and it will be replaced with
#! the value of `variable` (but for global variables only).
DeclareOperation("IsRelationOfReflexibleManiplex", [IsManiplex, IsString]);
#! @BeginExampleSession
#! gap> M := ReflexibleManiplex([8,6],"(r0 r1)^4 (r1 r2)^3");;
#! gap> IsRelationOfReflexibleManiplex(M, "(r0 r1 r2)^3");
#! false
#! gap> IsRelationOfReflexibleManiplex(M, "(r0 r1 r2)^12");
#! true
#! @EndExampleSession

#! @Arguments parent, words
#! @Description Given a <A>parent</A> group and a list of strings that
#! represent words in r0, r1, etc, returns a function. That function
#! accepts a list of positive integers L, and returns the quotient of
#! <A>parent</A> by the relations that set the order of each <A>words[i]</A>
#! to L[i].
#! @BeginExampleSession
#! gap> f := SggiFamily(Sggi([4,4]), ["r0 r1 r2 r1"]);
#! function( orders ) ... end
#! gap> g := f([3]);
#! <fp group on the generators [ r0, r1, r2 ]>
#! gap> Size(g);
#! 72
#! gap> h := f([6]);
#! <fp group on the generators [ r0, r1, r2 ]>
#! gap> IsQuotient(h,g);
#! true
#! @EndExampleSession
#! One of the advantages of building an SggiFamily is that testing whether
#! one member of the family is a quotient of another member can be
#! done quite quickly.
DeclareOperation("SggiFamily", [IsGroup, IsList]);


# @Arguments g
# @Returns `IsList`
# @Description Given a string group generated by involutions, it returns the associated Schlafli Symbol for the group.
# DeclareAttribute("SchlafliSymbol",[IsGroup]);
# @BeginExampleSession
# gap> g := Group((1,2),(2,3),(3,4));;
# gap> SchlafliSymbol(g);
# [3,3]
# @EndExampleSession

#! @Arguments m
#! @Returns  IsBool
#! @Description Determines whether a given maniplex is C-connected (i.e., is the connection group a string C-group).
DeclareProperty("IsCConnected", IsManiplex);
#! @BeginExampleSession
#! gap> IsCConnected(ToroidalMap44([1,0]));
#! false
#! gap> IsCConnected(Prism(ToroidalMap44([1,0])));
#! true
#! @EndExampleSession

#! @Arguments g, I
#! @Returns IsSggi
#! @Description Given an Sggi <A>g</A>, returns the subgroup generated by those generators
#! with indices in <A>I</A>.
DeclareOperation("SectionSubgroup", [IsGroup, IsList]);
#! @BeginExampleSession
#! gap> g := AutomorphismGroup(Cube(5));;
#! gap> SectionSubgroup(g, [0, 2, 3]);
#! Group([ r0, r2, r3 ])
#! gap> Size(last);
#! 12
#! @EndExampleSession

#! @Arguments g
#! @Returns IsSggi
#! @Description Given an Sggi <A>g</A>, returns the vertex-figure subgroup; that is, the subgroup
#! generated by all generators except for the first one.
DeclareOperation("VertexFigureSubgroup", [IsGroup]);
#! @BeginExampleSession
#! gap> VertexFigureSubgroup(AutomorphismGroup(Cube(3)));
#! Group([ r1, r2 ])
#! gap> Size(last);
#! 6
#! @EndExampleSession

#! @Arguments g
#! @Returns IsSggi
#! @Description Given an Sggi <A>g</A>, returns the facet subgroup; that is, the subgroup
#! generated by all generators except for the last one.
DeclareOperation("FacetSubgroup", [IsGroup]);
#! @BeginExampleSession
#! gap> FacetSubgroup(AutomorphismGroup(Cube(3)));
#! Group([ r0, r1 ])
#! gap> Size(last);
#! 8
#! @EndExampleSession

#! @Chapter Group Constructors
#! @Section String rotation groups

DeclareGlobalVariable("UNIVERSAL_ROT_FREE_GROUPS");


#! @Arguments n
#! Returns the rotation subgroup of the universal Coxeter Group of rank n.
DeclareOperation("UniversalRotationGroup", [IsInt]);
#! @BeginExampleSession
#! gap> UniversalRotationGroup(3);
#! <fp group of size infinity on the generators [ s1, s2 ]>
#! @EndExampleSession

#! @Arguments sym
#! Returns the rotation subgroup of the Coxeter Group with Schlafli symbol sym.
DeclareOperation("UniversalRotationGroup", [IsList]);
#! @BeginExampleSession
#! gap> UniversalRotationGroup([4,4]);
#! <fp group of size infinity on the generators [ s1, s2 ]>
#! gap> UniversalRotationGroup([3,3,3]);
#! <fp group of size 60 on the generators [ s1, s2, s3 ]>
#! @EndExampleSession
