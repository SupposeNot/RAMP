<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Databases">
<Heading>Databases</Heading>

<Section Label="Chapter_Databases_Section_Regular_polyhedra">
<Heading>Regular polyhedra</Heading>

 Eventually we should put information here about where the data comes from.
<ManSection>
  <Func Arg="maniplexes, filename, attributeNames" Name="WriteManiplexesToFile" />
 <Description>
Writes the data in <A>maniplexes</A> to the designated file,
 including the defining information and the values of the attributes in
 <A>attributeNames</A>. 
 This calls <Code>DatabaseString</Code> on each maniplex in <A>maniplexes</A> to get
 the file representation.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="filename" Name="ManiplexesFromFile" />
 <Returns>IsList
</Returns>
 <Description>
Reads the maniplexes from <A>filename</A> in the data directory
 of RAMP and returns them as a list.
 Note that for performance reasons, some safety checks are disabled for data
 read from a file. For example, <Code>AbstractRegularPolytope</Code> usually checks its
 input to make sure that it defines a polytope, but <Code>ManiplexesFromFile</Code>
 just assumes that any maniplex defined using <Code>AbstractRegularPolytope</Code> really
 is a polytope.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="sizerange" Name="DegeneratePolyhedra" />
 <Returns>IsList
</Returns>
 <Description>
Gives all degenerate polyhedra (of type <Math>\{2, q\}</Math> and <Math>\{p, 2\}</Math>) with
 sizes in <A>sizerange</A>. Also accepts a single integer
 <Emph>maxsize</Emph> as input to indicate a sizerange of <Code>[1..maxsize]</Code>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> DegeneratePolyhedra(24);
[ AbstractRegularPolytope([ 2, 2 ]), AbstractRegularPolytope([ 2, 3 ]), 
  AbstractRegularPolytope([ 3, 2 ]), AbstractRegularPolytope([ 2, 4 ]), 
  AbstractRegularPolytope([ 4, 2 ]), AbstractRegularPolytope([ 2, 5 ]), 
  AbstractRegularPolytope([ 5, 2 ]), AbstractRegularPolytope([ 2, 6 ]), 
  AbstractRegularPolytope([ 6, 2 ]) ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="FlatRegularPolyhedra" />
 <Returns>IsList
</Returns>
 <Description>
Gives all nondegenerate flat regular polyhedra with
 sizes in <A>sizerange</A>. Also accepts a single integer
 <Emph>maxsize</Emph> as input to indicate a sizerange of <Code>[1..maxsize]</Code>.
 Currently supports a maxsize of 4000 or less.
 </Description>
</ManSection>


<Example><![CDATA[
gap> FlatRegularPolyhedra([10..24]);
[ AbstractRegularPolytope([ 2, 3 ]), AbstractRegularPolytope([ 3, 2 ]), 
  AbstractRegularPolytope([ 2, 4 ]), AbstractRegularPolytope([ 4, 2 ]), 
  AbstractRegularPolytope([ 2, 5 ]), AbstractRegularPolytope([ 5, 2 ]), 
  AbstractRegularPolytope([ 4, 3 ], "r2 r1 r0 r1 = (r0 r1)^2 r1 (r1 r2)^1, r2 r1 r2 r1 r0 r1 = (r0\
 r1)^3 (r1 r2)^2"), 
  ReflexibleManiplex([ 3, 4 ], "(r2*r1)^2*r1^2*r0*r1*r2*r1*r0,(r2*r1)^3*(r1*r0)^2*r1*r2*(r1*r0)^2"\
), AbstractRegularPolytope([ 2, 6 ]), AbstractRegularPolytope([ 6, 2 ]) ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="RegularToroidalPolyhedra44" />
 <Returns>IsList
</Returns>
 <Description>
Gives all regular toroidal polyhedra of type <Math>\{4,4\}</Math>
 with sizes in <A>sizerange</A>. Also accepts a single integer
 <Emph>maxsize</Emph> as input to indicate a sizerange of <Code>[1..maxsize]</Code>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> RegularToroidalPolyhedra44([60..100]);
[ AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2)^4"), 
  AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^3") ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="RegularToroidalPolyhedra36" />
 <Returns>IsList
</Returns>
 <Description>
Gives all regular toroidal polyhedra of type <Math>\{3,6\}</Math>
 with sizes in <A>sizerange</A>. Also accepts a single integer
 <Emph>maxsize</Emph> as input to indicate a sizerange of <Code>[1..maxsize]</Code>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> RegularToroidalPolyhedra36([100..150]);
[ AbstractRegularPolytope([ 3, 6 ], "(r0 r1 r2)^6"), 
  AbstractRegularPolytope([ 3, 6 ], "(r0 r1 r2 r1 r2)^4") ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallRegularPolyhedraFromFile" />
 <Returns>IsList
</Returns>
 <Description>
Gives all regular polyhedra with sizes in <A>sizerange</A> flags
 that are stored separately in a file. These are polyhedra that
 are not part of one of several infinite families that are covered
 by the other generators. The return value of this function is
 unstable and may change as more infinite familes of polyhedra
 are identified and written as separate generators.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SmallRegularPolyhedraFromFile(64);
[ Simplex(3), AbstractRegularPolytope([ 3, 6 ], "(r2*r0*r1)^2*(r0*r2*r1)^2 "), CrossPolytope(3), 
  AbstractRegularPolytope([ 6, 3 ], "(r0*r2*r1)^2*(r2*r0*r1)^2 "), Cube(3), 
  AbstractRegularPolytope([ 5, 5 ], "r1*r2*r0*(r1*r0*r2)^2 "), 
  AbstractRegularPolytope([ 3, 5 ], "(r2*r0*r1)^3*(r0*r2*r1)^2 "), 
  AbstractRegularPolytope([ 5, 3 ], "(r0*r2*r1)^3*(r2*r0*r1)^2 ") ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallRegularPolyhedra" />
 <Returns>IsList
</Returns>
 <Description>
Gives all regular polyhedra with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 4000 or less.
 You can also set options <Code>nondegenerate</Code>, <Code>nonflat</Code>, and <Code>nontoroidal</Code>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> L1 := SmallRegularPolyhedra(500);;
gap> L2 := SmallRegularPolyhedra(1000 : nondegenerate);;
gap> L3 := SmallRegularPolyhedra(2000 : nondegenerate, nonflat);;
gap> Length(SmallRegularPolyhedra(64));
53
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallDegenerateRegular4Polytopes" />
 <Returns>IsList
</Returns>
 <Description>
Gives all degenerate regular 4-polytopes with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 8000 or less. 
 </Description>
</ManSection>


<Example><![CDATA[
gap>  SmallDegenerateRegular4Polytopes([64]);
[ AbstractRegularPolytope([ 4, 2, 4 ]), AbstractRegularPolytope([ 2, 8, 2 ]), 
  regular 4-polytope of type [ 4, 4, 2 ] with 64 flags, 
  ReflexibleManiplex([ 2, 4, 4 ], "(r2*r1*r2*r3)^2,(r1*r2*r3*r2)^2") ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallRegular4Polytopes" />
 <Returns>IsList
</Returns>
 <Description>
Gives all regular 4-polytopes with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 4000 or less.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SmallRegular4Polytopes([100]);
[ AbstractRegularPolytope([ 5, 2, 5 ]) ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallChiralPolyhedra" />
 <Returns>IsList
</Returns>
 <Description>
Gives all chiral polyhedra with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 4000 or less.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SmallChiralPolyhedra(100);
[ AbstractRotaryPolytope([ 4, 4 ], "s1*s2^-2*s1^2*s2^-1,(s1^-1*s2^-1)^2"), 
  AbstractRotaryPolytope([ 4, 4 ], "s2*s1^-1*s2*s1^2*s2^2*s1^-1,(s1^-1*s2^-1)^2"), 
  AbstractRotaryPolytope([ 3, 6 ], "s2^-1*s1*s2^-2*s1^-1*s2*s1^-1*s2^-2,(s1^-1*s2^-1)^2"), 
  AbstractRotaryPolytope([ 6, 3 ], "s1*s2^-1*s1^2*s2*s1^-1*s2*s1^2,(s2*s1)^2") ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallChiral4Polytopes" />
 <Returns>IsList
</Returns>
 <Description>
Gives all chiral 4-polytopes with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 4000 or less.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SmallChiral4Polytopes([200..250]);
[ AbstractRotaryPolytope([ 3, 4, 4 ], "s3^-1*s2^-2*s1^-1*s3*s1,s2^-1*s3^-2*s2^2*s3,(s2^-1*s3^-1)^2,(s1^-1*s2^-1)^2"), 
  AbstractRotaryPolytope([ 4, 4, 3 ], "s1*s2^2*s3*s1^-1*s3^-1,s2*s1^2*s2^-2*s1^-1,(s2*s1)^2,(s3*s2)^2"), 
  AbstractRotaryPolytope([ 4, 4, 4 ], "s2*s3^-2*s2^2*s3^-1,s3*s2*s1^-1*s3^2*s1,s3^-1*s2^-2*s1^-1*s3*s1,(s2^-1*s3^-1)^2,s1^-1*s2^-2*s1^2*s2,(s1^-1*s2^-1)^2") ]
]]></Example>


<ManSection>
  <Func Arg="sizerange" Name="SmallReflexible3Maniplexes" />
 <Returns>IsList
</Returns>
 <Description>
Gives all regular 4-polytopes with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 2000 or less.
 If the option <Code>nonpolytopal</Code> is set, only returns maniplexes that
 are not polyhedra.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="minsize, maxsize[, func1, val1, func2, val2, ...]" Name="SRP" />
 <Returns>IsList
</Returns>
 <Description>
Returns a list of all regular polyhedra with at least <A>minsize</A>
 at at most <A>maxsize</A> flags. Optionally, you may include any number of pairs
 of functions and values, in which case this only returns those polyhedra such that
 the given functions have the given values.
 The name of this function is temporary and this function is here as a proof-of-concept.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SRP(1,200,SchlafliSymbol,[4,4]);
[ FlatOrientablyRegularPolyhedron(4,4,-1,1), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2)^4"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^3"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^4"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2)^6"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^5") ]
gap> SRP(1,200,SchlafliSymbol,[4,4],IsFlat,false);
[ AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2)^4"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^3"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^4"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2)^6"), AbstractRegularPolytope([ 4, 4 ], "(r0 r1 r2 r1)^5") ]
gap> SRP(1,32,p->SchlafliSymbol(p)[1], 4);
[ AbstractRegularPolytope([ 4, 2 ]), AbstractRegularPolytope([ 4, 3 ], "r2 r1 r0 r1 = (r0 r1)^2 r1 (r1 r2)^1, r2 r1 r2 r1 r0 r1 = (r0 r1)^3 (r1 r2)^2"), FlatOrientablyRegularPolyhedron(4,4,-1,1) ]
]]></Example>


<ManSection>
  <Func Arg="I, sizerange" Name="SmallTwoOrbit3Maniplexes" />
 <Returns>IsList
</Returns>
 <Description>
Gives all two-orbit 3-maniplexes in class <Math>2_I</Math> with sizes in <A>sizerange</A> flags.
 Currently supports a <Code>maxsize</Code> of 1000 or less.
 </Description>
</ManSection>


<Example><![CDATA[
gap> L := SmallTwoOrbit3Maniplexes([0], 100);
[ TwoOrbit3ManiplexClass2_0([ 10, 4 ], "  r0*a21*a101*a21^-1, r0*a21^-1*a101*r0*a101*a21 "),
 TwoOrbit3ManiplexClass2_0([ 14, 3 ], "  r0*a21*a101*a21^-1, r0*a101*a21*(a101*r0)^2*a21^-1 ") ]
]]></Example>


</Section>


<Section Label="Chapter_Databases_Section_System_internal_representations">
<Heading>System internal representations</Heading>

<ManSection>
  <Oper Arg="M" Name="DatabaseString" Label="for IsManiplex"/>
 <Returns>String
</Returns>
 <Description>
Given a maniplex <A>M</A>, returns a string representation of
 <A>M</A> suitable for saving in a database for later retrieval.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="maniplexString" Name="ManiplexFromDatabaseString" Label="for IsString"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given a string <A>maniplexString</A>, representing a maniplex stored
 in a database, returns the maniplex that is represented.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="str" Name="InterpolatedString" Label="for IsString"/>
 <Returns>IsString
</Returns>
 <Description>
Given a string, replaces each instance of "&#36;variable" with
 String(EvalString(variable)). Any character which cannot be used in a
 variable name (such as spaces, commas, etc.) marks the end of the variable name.
<P/>
 Note that, due to limitations with EvalString, only global variables can be
 interpolated this way.
 </Description>
</ManSection>


<Example><![CDATA[
gap> n := 5;;
gap> InterpolatedString("2 + 3 = $n");
"2 + 3 = 5"
gap> InterpolatedString("2 + 3 = $n, right?");
"2 + 3 = 5, right?"
gap> nn := 17;;
gap> InterpolatedString("$n and $nn are different");
"5 and 17 are different"
]]></Example>


</Section>


</Chapter>

