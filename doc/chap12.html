<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (RAMP) - Chapter 12: Graphs for Maniplexes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap12"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap11.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap13.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap12_mj.html">[MathJax on]</a></p>
<p><a id="X84DE212D847339C0" name="X84DE212D847339C0"></a></p>
<div class="ChapSects"><a href="chap12.html#X84DE212D847339C0">12 <span class="Heading">Graphs for Maniplexes</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12.html#X8533D8D97CDE9DF1">12.1 <span class="Heading">Graph families</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7DC6E7897C266B73">12.1-1 HeawoodGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X823F43217A6C375D">12.1-2 PetersenGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7E247B6783FBF9F9">12.1-3 CirculantGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7D9F8CF285289177">12.1-4 CompleteBipartiteGraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12.html#X8142EE7180458E04">12.2 <span class="Heading">Graph constructors for maniplexes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7FB3733D81739F2C">12.2-1 DirectedGraphFromListOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X82810A0A7CF30BB4">12.2-2 GraphFromListOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X86BE61C88420C6F6">12.2-3 UnlabeledFlagGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X791AEF1C7AA7138C">12.2-4 FlagGraphWithLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X809815D08250B57F">12.2-5 LayerGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7BB443CD832DAC12">12.2-6 Skeleton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X85F3D43E7D1BA8E5">12.2-7 CoSkeleton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7A0FB13C7EF68CBB">12.2-8 Hasse</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X860AACCF860A3F66">12.2-9 QuotientByLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X84FE2C317CFA6AFD">12.2-10 EdgeLabeledGraphFromEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X83DD0B547D5DDE35">12.2-11 EdgeLabeledGraphFromLabeledEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7A958E7C821DD8F8">12.2-12 FlagGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X82A8C3AD871EC6D7">12.2-13 UnlabeledSimpleGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X84263C6C81AB458C">12.2-14 EdgeLabelPreservingAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7D7BF5608431FED8">12.2-15 Simple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X8159C96B8757873F">12.2-16 ConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7A53CE8B820FD6A1">12.2-17 PRGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X85BBB22F8196DC0B">12.2-18 CPRGraphFromGroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7E52D3CB7A84139A">12.2-19 AdjacentVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X78BAE96984A79ACD">12.2-20 LabeledAdjacentVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X791A59B97A44470F">12.2-21 SemiEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X82490C307F022606">12.2-22 LabeledSemiEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X811C8FB3842D6D2E">12.2-23 LabeledDarts</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X8529379678912775">12.2-24 DerivedGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X83990BFD7D887A02">12.2-25 ViewGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X8147A743805AD49D">12.2-26 ConnectionGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X863F65F6865859F1">12.2-27 FlagGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap12.html#X7E7E64817A09366F">12.2-28 LabeledDarts</a></span>
</div></div>
</div>

<h3>12 <span class="Heading">Graphs for Maniplexes</span></h3>

<p><a id="X8533D8D97CDE9DF1" name="X8533D8D97CDE9DF1"></a></p>

<h4>12.1 <span class="Heading">Graph families</span></h4>

<p><a id="X7DC6E7897C266B73" name="X7DC6E7897C266B73"></a></p>

<h5>12.1-1 HeawoodGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeawoodGraph</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code></p>

<p>Heawood Graph as described at https://www.distanceregular.org/graphs/heawood.html</p>

<p><a id="X823F43217A6C375D" name="X823F43217A6C375D"></a></p>

<h5>12.1-2 PetersenGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PetersenGraph</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code></p>

<p>Petersen Graph as described at https://www.gap-system.org/Manuals/pkg/grape/htm/CHAP002.htm</p>

<p><a id="X7E247B6783FBF9F9" name="X7E247B6783FBF9F9"></a></p>

<h5>12.1-3 CirculantGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CirculantGraph</code>( <var class="Arg">n</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code></p>

<p>Given an integer <var class="Arg">n</var> and a list <var class="Arg">L</var>, this returns the Circulant Graph with <var class="Arg">n</var> vertices. For each <code class="code">i</code> in the list <var class="Arg">L</var> and each vertex <code class="code">v</code>, there is an edge from <code class="code">v</code> to <code class="code">v+i</code> and <code class="code">v-i</code> (mod <var class="Arg">n</var>)</p>

<p><a id="X7D9F8CF285289177" name="X7D9F8CF285289177"></a></p>

<h5>12.1-4 CompleteBipartiteGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompleteBipartiteGraph</code>( <var class="Arg">n</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code></p>

<p>Given two integers <var class="Arg">n, m</var>, this returns the Complete Bipartite Graph <code class="code">K_{n,m}</code>.</p>

<p><a id="X8142EE7180458E04" name="X8142EE7180458E04"></a></p>

<h4>12.2 <span class="Heading">Graph constructors for maniplexes</span></h4>

<p><a id="X7FB3733D81739F2C" name="X7FB3733D81739F2C"></a></p>

<h5>12.2-1 DirectedGraphFromListOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectedGraphFromListOfEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns a directed graph.</p>

<p>Given a list of vertices and a list of directed-edges (represented as ordered pairs), this outputs the directed graph with the appropriate vertex and directed-edge set.</p>

<p>Here we have a directed cycle on 3 vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DirectedGraphFromListOfEdges([1,2,3],[[1,2],[2,3],[3,1]]);</span>
rec( adjacencies := [ [ 2 ], [ 3 ], [ 1 ] ], group := Group(()), 
 isGraph := true, names := [ 1, 2, 3 ], order := 3, 
 representatives := [ 1, 2, 3 ], schreierVector := [ -1, -2, -3 ] )
</pre></div>

<p><a id="X82810A0A7CF30BB4" name="X82810A0A7CF30BB4"></a></p>

<h5>12.2-2 GraphFromListOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphFromListOfEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a list of vertices and a list of (directed) edges (represented as ordered pairs), this outputs the simple underlying graph with the appropriate vertex and directed-edge set.</p>

<p>Here we have a simple complete graph on 4 vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GraphFromListOfEdges([1,2,3,4],[[1,2],[2,3],[3,1], [1,4], [2,4], [3,4]]);</span>
rec( 
 adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ],
 group := Group(()), isGraph := true, isSimple := true, 
 names := [ 1, 2, 3, 4 ], order := 4, representatives := [ 1, 2, 3, 4 ]
   , schreierVector := [ -1, -2, -3, -4 ] )
</pre></div>

<p><a id="X86BE61C88420C6F6" name="X86BE61C88420C6F6"></a></p>

<h5>12.2-3 UnlabeledFlagGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnlabeledFlagGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a group (assumed to be the connection group of a maniplex), this outputs the simple underlying flag graph.</p>

<p>Here we build the flag graph for the cube from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnlabeledFlagGraph(ConnectionGroup(Cube(3)));</span>
rec( 
 adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
     [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
     [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
     [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
     [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], [ 17, 22, 24 ], 
     [ 1, 10, 38 ], [ 18, 32, 40 ], [ 19, 41, 48 ], [ 11, 35, 44 ], 
     [ 12, 19, 34 ], [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], 
     [ 5, 9, 16 ], [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
     [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
     [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], [ 29, 31, 46 ], 
     [ 16, 21, 42 ], [ 6, 22, 29 ], [ 26, 40, 43 ], [ 36, 38, 42 ], 
     [ 14, 23, 46 ], [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
     [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 48 ], order := 48, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
     31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 
     47, 48 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, 
     -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, 
     -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48 ] )
</pre></div>

<p>This also works with a maniplex input. Here we build the flag graph for the cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnlabeledFlagGraph(Cube(3));</span>
</pre></div>

<p><a id="X791AEF1C7AA7138C" name="X791AEF1C7AA7138C"></a></p>

<h5>12.2-4 FlagGraphWithLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagGraphWithLabels</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a triple [<code class="code">IsGraph</code>, <code class="code">IsList</code>, <code class="code">IsList</code>].</p>

<p>Given a group (assumed to be the connection group of a maniplex), this outputs a triple [graph,list,list]. The graph is the unlabeled flag graph of the connection group. The first list gives the undirected edges in the flag graphs. The second list gives the labels for these edges.</p>

<p>Here we again build the flag graph for the cube from its connection group, but this time keep track of labels of the edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= FlagGraphWithLabels(ConnectionGroup(Cube(3)));</span>
[ rec( 
     adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
         [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
         [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
         [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
         [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], 
         [ 17, 22, 24 ], [ 1, 10, 38 ], [ 18, 32, 40 ], 
         [ 19, 41, 48 ], [ 11, 35, 44 ], [ 12, 19, 34 ], 
         [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], [ 5, 9, 16 ], 
         [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
         [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
         [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], 
         [ 29, 31, 46 ], [ 16, 21, 42 ], [ 6, 22, 29 ], 
         [ 26, 40, 43 ], [ 36, 38, 42 ], [ 14, 23, 46 ], 
         [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
         [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
     isSimple := true, names := [ 1 .. 48 ], order := 48, 
     representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 
         14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 
         29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 
         44, 45, 46, 47, 48 ], 
     schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
         -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, 
         -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, 
         -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, 
         -48 ] ), 
 [ [ 1, 3 ], [ 1, 11 ], [ 1, 20 ], [ 2, 7 ], [ 2, 13 ], [ 2, 18 ], 
     [ 3, 4 ], [ 3, 10 ], [ 4, 25 ], [ 4, 34 ], [ 5, 26 ], [ 5, 28 ], 
     [ 5, 35 ], [ 6, 7 ], [ 6, 13 ], [ 6, 41 ], [ 7, 8 ], [ 8, 27 ], 
     [ 8, 32 ], [ 9, 28 ], [ 9, 33 ], [ 9, 35 ], [ 10, 20 ], 
     [ 10, 45 ], [ 11, 14 ], [ 11, 23 ], [ 12, 15 ], [ 12, 17 ], 
     [ 12, 24 ], [ 13, 31 ], [ 14, 25 ], [ 14, 44 ], [ 15, 45 ], 
     [ 15, 47 ], [ 16, 18 ], [ 16, 28 ], [ 16, 40 ], [ 17, 19 ], 
     [ 17, 27 ], [ 18, 21 ], [ 19, 22 ], [ 19, 24 ], [ 20, 38 ], 
     [ 21, 32 ], [ 21, 40 ], [ 22, 41 ], [ 22, 48 ], [ 23, 35 ], 
     [ 23, 44 ], [ 24, 34 ], [ 25, 37 ], [ 26, 38 ], [ 26, 42 ], 
     [ 27, 30 ], [ 29, 39 ], [ 29, 41 ], [ 29, 48 ], [ 30, 32 ], 
     [ 30, 47 ], [ 31, 33 ], [ 31, 39 ], [ 33, 46 ], [ 34, 37 ], 
     [ 36, 43 ], [ 36, 45 ], [ 36, 47 ], [ 37, 48 ], [ 38, 43 ], 
     [ 39, 46 ], [ 40, 42 ], [ 42, 43 ], [ 44, 46 ] ], 
 [ 3, 2, 1, 3, 1, 2, 2, 1, 3, 1, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 2, 3, 
     3, 2, 3, 1, 2, 3, 1, 2, 2, 1, 1, 3, 1, 2, 3, 1, 2, 3, 2, 3, 2, 2, 
     1, 1, 3, 2, 3, 2, 1, 1, 3, 3, 2, 3, 1, 1, 2, 1, 3, 3, 3, 2, 3, 1, 
     2, 3, 1, 2, 1, 2 ] ]
</pre></div>

<p>This also works with a maniplex input. Here we build the flag graph for the cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= FlagGraphWithLabels(Cube(3));</span>
</pre></div>

<p><a id="X809815D08250B57F" name="X809815D08250B57F"></a></p>

<h5>12.2-5 LayerGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LayerGraph</code>( [<var class="Arg">group</var>, <var class="Arg">int</var>, <var class="Arg">int</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a group (assumed to be the connection group of a maniplex), and two integers, this outputs the simple underlying graph given by incidences of faces of those ranks. Note: There are no warnings yet to make sure that i,j are bounded by the rank.</p>

<p>Here we build the graph given by the 6 faces and 12 edges of a cube from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LayerGraph(ConnectionGroup(Cube(3)),2,1);</span>
rec( 
 adjacencies := [ [ 7, 10, 12, 17 ], [ 8, 10, 15, 18 ], 
     [ 7, 9, 13, 14 ], [ 8, 11, 13, 16 ], [ 9, 12, 16, 18 ], 
     [ 11, 14, 15, 17 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 2 ], 
     [ 4, 6 ], [ 1, 5 ], [ 3, 4 ], [ 3, 6 ], [ 2, 6 ], [ 4, 5 ], 
     [ 1, 6 ], [ 2, 5 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 18 ], order := 18, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18 ] )
</pre></div>

<p>This also works with a maniplex input. Here we build the graph given by the 6 faces and 12 edges of a cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LayerGraph(Cube(3),2,1);;</span>
</pre></div>

<p><a id="X7BB443CD832DAC12" name="X7BB443CD832DAC12"></a></p>

<h5>12.2-6 Skeleton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Skeleton</code>( <var class="Arg">maniplex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a maniplex, this outputs the 0-1 skeleton. The vertices are the 0-faces, and the edges are the 1-faces.</p>

<p>Here we build the skeleton of the dodecahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Skeleton(Dodecahedron());;</span>
</pre></div>

<p><a id="X85F3D43E7D1BA8E5" name="X85F3D43E7D1BA8E5"></a></p>

<h5>12.2-7 CoSkeleton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoSkeleton</code>( <var class="Arg">maniplex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a maniplex, this outputs the <span class="Math">(n-1)</span>-<span class="Math">(n-2)</span> skeleton, i.e., the 0-1 skeleton of the dual. The vertices are the <span class="Math">(n-1)</span>-faces, and the edges are the <span class="Math">(n-2)</span>-faces.</p>

<p>Here we build the co-skeleton of the dodecahedron and verify that it is the skeleton of the icosahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=CoSkeleton(Dodecahedron());;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Skeleton(Icosahedron());;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g=h;</span>
true
</pre></div>

<p><a id="X7A0FB13C7EF68CBB" name="X7A0FB13C7EF68CBB"></a></p>

<h5>12.2-8 Hasse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Hasse</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns a directed graph.</p>

<p>Given a group, assumed to be the connection group of a maniplex, this outputs the Hasse Diagram as a directed graph. Note: The unique minimal and maximal face are assumed.</p>

<p>Here we build the Hasse Diagram of a 3-simplex from its representation as a maniplex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hasse(Simplex(3));</span>
rec( 
 adjacencies := [ [  ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 2, 4 ], 
     [ 2, 3 ], [ 3, 5 ], [ 2, 5 ], [ 4, 5 ], [ 3, 4 ], [ 6, 9, 10 ], 
     [ 6, 7, 11 ], [ 8, 10, 11 ], [ 7, 8, 9 ], [ 12, 13, 14, 15 ] ], 
 group := Group(()), isGraph := true, names := [ 1 .. 16 ], 
 order := 16, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16 ] )
</pre></div>

<p><a id="X860AACCF860A3F66" name="X860AACCF860A3F66"></a></p>

<h5>12.2-9 QuotientByLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuotientByLabel</code>( <var class="Arg">object</var>, <var class="Arg">list</var>, <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a graph, its edges, and its edge labels, and a sublist of labels, this creates the underlying simple graph of the quotient identifying vertices connected by labels not in the sublist.</p>

<p>Here we start with the flag graph of the 3-cube (with edge labels 1,2,3), and identify any vertices not connected by edge by edges of label 1. We can then check that this new graph is bipartite.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=Cube(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=FlagGraphWithLabels(P);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=f[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ed:=f[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lab:=f[3];  #Note This triple is to be replace by a single object.</span>
[ 3, 2, 1, 3, 1, 2, 1, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 2, 3, 1, 3, 1, 2, 3, 2, 1, 1, 2, 2, 3, 1, 3, 1, 2, 
  3, 1, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 1, 3, 1, 3, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 2, 2, 2, 3, 3, 1, 3, 1, 1, 3, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q:=QuotientByLabel(g,ed,lab,[1]);</span>
rec( adjacencies := [ [ 5, 6, 8 ], [ 3, 4, 7 ], [ 2, 6, 8 ], [ 2, 5, 8 ], [ 1, 4, 7 ], [ 1, 3, 7 ], [ 2, 5, 6 ], [ 1, 3, 4 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 8 ], order := 8, representatives := [ 1, 2, 3, 4, 5, 6, 7, 8 ], schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBipartite(Q);</span>
true
</pre></div>

<p><a id="X84FE2C317CFA6AFD" name="X84FE2C317CFA6AFD"></a></p>

<h5>12.2-10 EdgeLabeledGraphFromEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeLabeledGraphFromEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given a list of vertices, a list of edges, and a list of edge labels, this represents the edge labeled (multi)-graph with those parameters. Semi-edges are represented by a singleton in the edge list. Loops are represented by edges [i,i]</p>

<p>Here we have an edge labeled cycle graph with 6 vertices and edges alternating in labels 0,1.</p>


<div class="example"><pre>
V:=[1..6];;
Edges:=[[1,2],[2,3],[3,4],[4,5],[5,6],[6,1]];;
L:=[0,1,0,1,0,1];;
gamma:=EdgeLabeledGraphFromEdges(V,Edges,L);
</pre></div>

<p><a id="X83DD0B547D5DDE35" name="X83DD0B547D5DDE35"></a></p>

<h5>12.2-11 EdgeLabeledGraphFromLabeledEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeLabeledGraphFromLabeledEdges</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given a list of labeled edges this represents the edge labeled (multi)-graph with those parameters. Semi-edges are represented by a singleton in the edge list.</p>


<div class="example"><pre>
L:=[[[1],0],[[2],0],  [ [1,2],1]];;
X2:=EdgeLabeledGraphFromLabeledEdges(L);
</pre></div>

<p><a id="X7A958E7C821DD8F8" name="X7A958E7C821DD8F8"></a></p>

<h5>12.2-12 FlagGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given group, assumed to be a connection group, output the labeled flag graph. The input could also be a premaniplex, then the connection group is calculated.</p>

<p>Here we have the flag graph of the 3-simplex from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=ConnectionGroup(Simplex(3));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma:=FlagGraph(C);</span>
Edge labeled graph with 24 vertices, and edge labels [ 0, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">STG3(4,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FlagGraph(last);</span>
Edge labeled graph with 3 vertices, and edge labels [ 0, 1, 2, 3 ]
</pre></div>

<p><a id="X82A8C3AD871EC6D7" name="X82A8C3AD871EC6D7"></a></p>

<h5>12.2-13 UnlabeledSimpleGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnlabeledSimpleGraph</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>.</p>

<p>Given an edge labeled (multi) graph, it returns the underlying simple graph, with semi-edges, loops, and muliple-edges removed.</p>

<p>Here we have underlying simple graph for the flag graph of the cube.</p>


<div class="example"><pre>
gamma:=UnlabeledSimpleGraph(FlagGraph(Cube(3)));
</pre></div>

<p><a id="X84263C6C81AB458C" name="X84263C6C81AB458C"></a></p>

<h5>12.2-14 EdgeLabelPreservingAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeLabelPreservingAutomorphismGroup</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGroup</code>.</p>

<p>Given an edge labeled (multi) graph, it returns automorphism group (preserving the labels). Note, for now the labels are assumed to be [1..n]. Note This tends to be very slow. I would like to look for a way to go back and forth between flag automorphisms and poset automorphisms, as the latter are much faster to compute.</p>

<p>Here we have the automorphism group of the flag graph of the cube.</p>


<div class="example"><pre>
g:=EdgeLabelPreservingAutomorphismGroup(FlagGraph(Cube(3)));;
Size(g);
</pre></div>

<p><a id="X7D7BF5608431FED8" name="X7D7BF5608431FED8"></a></p>

<h5>12.2-15 Simple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Simple</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph </code>.</p>

<p>Given an edge labeled (multi) graph, it returns another edge labeled graph where semi-edges, loops, and multiple edges are removed. Note only the "first" edge label is retained if there are multiple edges.</p>

<p><a id="X8159C96B8757873F" name="X8159C96B8757873F"></a></p>

<h5>12.2-16 ConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConnectedComponents</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>.</p>

<p>Given an edge labeled (multi) graph and a list of labels, it returns connected components of the graph not using edges in the list of labels. Note if the second argument is not used, it is assumed to be an empty list, and the connected components of the original graph are returned.</p>

<p>Here we see that each connected component of the flag graph of the cube (which has labels 1,2,3) where edges of label 2 are removed, is a 4 cycle.</p>


<div class="example"><pre>
gamma:=ConnectedComponents(FlagGraph(Cube(3)),[2]);
</pre></div>

<p><a id="X7A53CE8B820FD6A1" name="X7A53CE8B820FD6A1"></a></p>

<h5>12.2-17 PRGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PRGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph </code>.</p>

<p>Given a group, it returns the permutation representation graph for that group. When the group is a string C-group this is also called a CPR graph. The labels of the edges are [1...r] where r is the number of generators of the group.</p>

<p>Here we see the CPR graph of the automorphism group of a cube (acting on its 8 vertices).</p>


<div class="example"><pre>
G:=AutomorphismGroup(Cube(3));
H:=Group(G.2,G.3);
phi:=FactorCosetAction(G,H);
G2:=Range(phi);
gamma:=PRGraph(G2);
</pre></div>

<p><a id="X85BBB22F8196DC0B" name="X85BBB22F8196DC0B"></a></p>

<h5>12.2-18 CPRGraphFromGroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CPRGraphFromGroups</code>( <var class="Arg">group</var>, <var class="Arg">subgroup</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given a group and a subgroup. Returns the graph of the action of the first group on cosets of the subgroup.</p>

<p><a id="X7E52D3CB7A84139A" name="X7E52D3CB7A84139A"></a></p>

<h5>12.2-19 AdjacentVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacentVertices</code>( <var class="Arg">EdgeLabeledGraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsList</code>.</p>

<p>Takes in an edge labeled graph and a vertex, and outputs a list of the adjacent vertices.</p>

<p><a id="X78BAE96984A79ACD" name="X78BAE96984A79ACD"></a></p>

<h5>12.2-20 LabeledAdjacentVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LabeledAdjacentVertices</code>( <var class="Arg">EdgeLabeledGraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsList, IsList</code>.</p>

<p>Takes in an edge labeled graph and a vertex, and outputs two lists: the list of adjacent vertices, and the labels of the corresponding edges.</p>

<p><a id="X791A59B97A44470F" name="X791A59B97A44470F"></a></p>

<h5>12.2-21 SemiEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemiEdges</code>( <var class="Arg">EdgeLabeledGraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsList</code>.</p>

<p>Takes in an edge labeled graph and a vertex, and outputs a list of semiedges</p>

<p><a id="X82490C307F022606" name="X82490C307F022606"></a></p>

<h5>12.2-22 LabeledSemiEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LabeledSemiEdges</code>( <var class="Arg">EdgeLabeledGraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsList, IsList</code>.</p>

<p>Takes in an edge labeled graph and a vertex, and outputs two lists: SemiEdges and their labels</p>

<p><a id="X811C8FB3842D6D2E" name="X811C8FB3842D6D2E"></a></p>

<h5>12.2-23 LabeledDarts</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LabeledDarts</code>( <var class="Arg">EdgeLabeledGraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsList</code>.</p>

<p>Takes in an edge labeled graph and outputs the labeled darts.</p>

<p><a id="X8529379678912775" name="X8529379678912775"></a></p>

<h5>12.2-24 DerivedGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DerivedGraph</code>( <var class="Arg">list</var>, <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given a a pre-maniplex (entered as its vertices and labeled darts) and voltages Return the connected derived graph from a pre-maniplex Careful, the order of our automorphisms. Do we want them on left or right? Does it matter? Can make another version with non-connected results, where the group is also an input</p>

<p>Here we can build the flag graph of a 3-orbit polyhedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:=[1,2,3];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ed:=[[1],[1],[1,2],[2],[2,3],[3],[3]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=[1,2,0,2,1,0,2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=EdgeLabeledGraphFromEdges(V,Ed,L);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=LabeledDarts(g);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">volt:=[ (1,2), (3,4), (), (), (3,4), (), (), (4,5), (2,3) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D:=DerivedGraph(V,L,volt);</span>
Edge labeled graph with 360 vertices, and edge labels [ 0, 1, 2 ]
</pre></div>

<p><a id="X83990BFD7D887A02" name="X83990BFD7D887A02"></a></p>

<h5>12.2-25 ViewGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ViewGraph</code>( <var class="Arg">G</var>, <var class="Arg">software_name</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsString</code>.</p>

<p>Given a Graph or EdgeLabeledGraph <var class="Arg">G</var>, outputs code to view the graph in other software. Currently mathematica and sage are supported.</p>

<p><a id="X8147A743805AD49D" name="X8147A743805AD49D"></a></p>

<h5>12.2-26 ConnectionGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConnectionGroup</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsPermGroup</code></p>

<p>Constructs the connection group from an edge labeled graph. Loops, semi-edges, and non-edges give fixed points. Graph is assumed to be coming from a maniplex. Some weird things could happen if it is not</p>

<p><a id="X863F65F6865859F1" name="X863F65F6865859F1"></a></p>

<h5>12.2-27 FlagGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagGraph</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: edgelabeledgraph</p>

<p>Returns the flag graph of a premaniplex <var class="Arg">M</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">STG3(4,1);;</span>
 gap&gt; FlagGraph(last);
Edge labeled graph with 3 vertices, and edge labels [ 0, 1, 2, 3 ]
</pre></div>

<p><a id="X7E7E64817A09366F" name="X7E7E64817A09366F"></a></p>

<h5>12.2-28 LabeledDarts</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LabeledDarts</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: list</p>

<p>Given a Premaniplex <var class="Arg">M</var>, returns the list of labeled darts from its flag graph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=STG2(5,[2,4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LabeledDarts(P);</span>
[ [ [ 1, 2 ], 0 ], [ [ 2, 1 ], 0 ], [ [ 1, 2 ], 1 ], [ [ 2, 1 ], 1 ], [ [ 1 ], 2 ], [ [ 1, 2 ], 3 ], [ [ 2, 1 ], 3 ], [ [ 1 ], 4 ], [ [ 2 ], 2 ], [ [ 2 ], 4 ] ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap11.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap13.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
