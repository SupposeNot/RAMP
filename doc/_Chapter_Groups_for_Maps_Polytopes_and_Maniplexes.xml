<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Groups_for_Maps_Polytopes_and_Maniplexes">
<Heading>Groups for Maps, Polytopes, and Maniplexes</Heading>

<Section Label="Chapter_Groups_for_Maps_Polytopes_and_Maniplexes_Section_Groups_of_Maps_Polytopes_and_Maniplexes">
<Heading>Groups of Maps, Polytopes, and Maniplexes</Heading>

<ManSection>
  <Attr Arg="M" Name="AutomorphismGroup" Label="for IsManiplex"/>
 <Description>
 Returns the automorphism group of <A>M</A>.
 This group is not guaranteed to be in any particular form. For particular permutation representations you should consider the various AutomorphismGroupOn... functions.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="AutomorphismGroupFpGroup" Label="for IsManiplex"/>
 <Description>
 Returns the automorphism group of <A>M</A> as a
 finitely presented group.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="AutomorphismGroupPermGroup" Label="for IsManiplex"/>
 <Description>
 Returns the automorphism group of <A>M</A> as a
 permutation group.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="AutomorphismGroupOnFlags" Label="for IsManiplex"/>
 <Description>
 Returns the automorphism group of <A>M</A> as a
 permutation group action on the flags of <A>M</A>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="ConnectionGroup" Label="for IsManiplex"/>
 <Description>
 Returns the connection group of <A>M</A> as a
 permutation group. We may eventually allow other types
 of connection groups.
 Synonym: MonodromyGroup
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="EvenConnectionGroup" Label="for IsManiplex"/>
 <Description>
 Returns the even-word subgroup of the connection group of <A>M</A> as a
 permutation group. 
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="RotationGroup" Label="for IsManiplex"/>
 <Description>
 Returns the rotation group of <A>M</A>.
 This group is not guaranteed to be in any particular form.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="ChiralityGroup" Label="for IsRotaryManiplex"/>
 <Description>
 Returns the chirality group of the rotary maniplex <A>M</A>.
 This is the kernel of the group epimorphism from the
 rotation group of <A>M</A> to the rotation group of its maximal
 reflexible quotient. In particular, the chirality group
 is trivial if and only if <A>M</A> is reflexible.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="ExtraRelators" Label="for IsReflexibleManiplex"/>
 <Description>
 For a reflexible maniplex <A>M</A>, returns the relators
 needed to define its automorphism group as a quotient of
 the string Coxeter group given by its Schlafli symbol.
 Not particularly robust at the moment.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="ExtraRotRelators" Label="for IsRotaryManiplex"/>
 <Description>
 For a reflexible maniplex <A>M</A>, returns the relators
 needed to define its rotation group as a quotient of
 the rotation group of a string Coxeter group given by its Schlafli symbol.
 Not particularly robust at the moment.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="permgroup" Name="IsManiplexable" Label="for IsPermGroup"/>
 <Returns><Code>Boolean</Code>.
</Returns>
 <Description>
Given a permutation group, it asks if the generators could be the connection group of a maniplex.
 That is to say, are each of the generators and their products fixed point free.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Groups_for_Maps_Polytopes_and_Maniplexes_Section_Sggis">
<Heading>Sggis</Heading>

<ManSection Label="UniversalSggi">
<Heading>UniversalSggi</Heading>
  <Oper Arg="n" Name="UniversalSggi" Label="for IsInt"/>
  <Oper Arg="sym" Name="UniversalSggi" Label="for IsList"/>
 <Returns><Code>IsFpGroup</Code>
</Returns>
 <Description>
In the first form, returns the universal Coxeter Group of rank n.
 In the second form, returns the Coxeter Group with Schlafli symbol sym.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="symbol[, relations]" Name="Sggi" Label="for IsList, IsList"/>
 <Returns><Code>IsFpGroup</Code>
</Returns>
 <Description>
Returns the sggi defined by the given Schlafli
 symbol and with the given relations. The relations can be given
 by a list of Tietze words or as a string of relators or relations
 that involve r0 etc. If no relations are given, then returns
 the universal sggi with the given Schlafli symbol.
<Example><![CDATA[
gap> g := Sggi([4,3,4], "(r0 r1 r2)^3, (r1 r2 r3)^3");;
gap> h := Sggi([4,4], "r0 = r2");;
gap> k := Sggi([infinity, infinity], [[1,2,1,2,1,2], [2,3,2,3,2,3]]);;
gap> k = Sggi([3,3]);
true
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="g" Name="IsGgi" Label="for IsGroup"/>
 <Returns>whether <A>g</A> is generated by involutions.  Or more specifically, whether GeneratorsOfGroup(<A>g</A>) all have
  order 2 or less.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Prop Arg="g" Name="IsStringy" Label="for IsGroup"/>
 <Returns>whether every pair of non-adjacent generators of <A>g</A> commute.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Prop Arg="g" Name="IsSggi" Label="for IsGroup"/>
 <Returns>whether <A>g</A> is a string group generated by involutions.  Equivalent to <Code>IsGgi(g) and IsStringy(g)</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="G" Name="IsStringC" Label="for IsGroup"/>
 <Description>
 For an sggi <A>G</A>, returns whether the group is
 a string C group. 
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="G" Name="IsStringCPlus" Label="for IsGroup"/>
 <Description>
 For a "string rotation group" <A>G</A>, returns whether the group is
 a string C+ group. It does not check whether <A>G</A>
 is a string rotation group.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="g, str" Name="SggiElement" Label="for IsGroup, IsString"/>
 <Returns>the element of <A>g</A> with underlying word <A>str</A>.
</Returns>
 <Description>
<Example><![CDATA[
gap> g := Group((1,2),(2,3),(3,4));;
gap> SggiElement(g, "r0 r1");
(1,3,2)
]]></Example>


 For convenience, you can also use a reflexible maniplex M in place
 of g, in which case <Code>AutomorphismGroup(M)</Code> is used for g.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="parent, words" Name="SggiFamily" Label="for IsGroup, IsList"/>
 <Description>
Given a <A>parent</A> group and a list of strings that
 represent words in r0, r1, etc, returns a function. That function
 accepts a list of positive integers L, and returns the quotient of
 <A>parent</A> by the relations that set the order of each <A>words[i]</A>
 to L[i].
<Example><![CDATA[
gap> f := SggiFamily(Sggi([4,4]), ["r0 r1 r2 r1"]);
function( orders ) ... end
gap> g := f([3]);
<fp group on the generators [ r0, r1, r2 ]>
gap> Size(g);
72
gap> h := f([6]);
<fp group on the generators [ r0, r1, r2 ]>
gap> IsQuotient(h,g);
true
]]></Example>


 One of the advantages of building an SggiFamily is that testing whether
 one member of the family is a quotient of another member can be
 done quite quickly.
 </Description>
</ManSection>


</Section>


</Chapter>

