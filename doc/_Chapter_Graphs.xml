<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Graphs">
<Heading>Graphs</Heading>

<Section Label="Chapter_Graphs_Section_Graphs_for_Maniplexes">
<Heading>Graphs for Maniplexes</Heading>

<ManSection>
  <Oper Arg="list, list" Name="DirectedGraphFromListOfEdges" Label="for IsList,IsList"/>
 <Returns><Code>IsGraph</Code>. Note this returns a directed graph.
</Returns>
 <Description>
Given a list of vertices and a list of directed-edges (represented as ordered pairs), this outputs the directed graph with the appropriate vertex and directed-edge set.
 </Description>
</ManSection>


 Here we have a directed cycle on 3 vertices.
<Example><![CDATA[
gap> g:= DirectedGraphFromListOfEdges([1,2,3],[[1,2],[2,3],[3,1]]);
rec( adjacencies := [ [ 2 ], [ 3 ], [ 1 ] ], group := Group(()), 
 isGraph := true, names := [ 1, 2, 3 ], order := 3, 
 representatives := [ 1, 2, 3 ], schreierVector := [ -1, -2, -3 ] )
]]></Example>


<ManSection>
  <Oper Arg="list, list" Name="GraphFromListOfEdges" Label="for IsList,IsList"/>
 <Returns><Code>IsGraph</Code>. Note this returns an undirected graph.
</Returns>
 <Description>
Given a list of vertices and a list of (directed) edges (represented as ordered pairs), this outputs the simple underlying graph with the appropriate vertex and directed-edge set.
 </Description>
</ManSection>


 Here we have a simple complete graph on 4 vertices.
<Example><![CDATA[
gap> g:= GraphFromListOfEdges([1,2,3,4],[[1,2],[2,3],[3,1], [1,4], [2,4], [3,4]]);
rec( 
 adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ],
 group := Group(()), isGraph := true, isSimple := true, 
 names := [ 1, 2, 3, 4 ], order := 4, representatives := [ 1, 2, 3, 4 ]
   , schreierVector := [ -1, -2, -3, -4 ] )
]]></Example>


<ManSection>
  <Oper Arg="group" Name="UnlabeledFlagGraph" Label="for IsGroup"/>
 <Returns><Code>IsGraph</Code>. Note this returns an undirected graph.
</Returns>
 <Description>
Given a group (assumed to be the connection group of a maniplex), this outputs the simple underlying flag graph.
 </Description>
</ManSection>


 Here we build the flag graph for the cube from its connection group.
<Example><![CDATA[
gap> g:= UnlabeledFlagGraph(ConnectionGroup(Cube(3)));
rec( 
 adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
     [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
     [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
     [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
     [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], [ 17, 22, 24 ], 
     [ 1, 10, 38 ], [ 18, 32, 40 ], [ 19, 41, 48 ], [ 11, 35, 44 ], 
     [ 12, 19, 34 ], [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], 
     [ 5, 9, 16 ], [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
     [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
     [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], [ 29, 31, 46 ], 
     [ 16, 21, 42 ], [ 6, 22, 29 ], [ 26, 40, 43 ], [ 36, 38, 42 ], 
     [ 14, 23, 46 ], [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
     [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 48 ], order := 48, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
     31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 
     47, 48 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, 
     -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, 
     -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48 ] )
]]></Example>


 This also works with a maniplex or polytope input. 
 Here we build the flag graph for the cube.
<Example><![CDATA[
gap> g:= UnlabeledFlagGraph(Cube(3));
]]></Example>


<ManSection>
  <Oper Arg="group" Name="FlagGraphWithLabels" Label="for IsGroup"/>
 <Returns>