<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Utility_Functions">
<Heading>Utility Functions</Heading>

<Section Label="Chapter_Utility_Functions_Section_System">
<Heading>System</Heading>

<ManSection>
  <InfoClass Name="InfoRamp" />
 <Description>
The InfoClass for the Ramp package.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Utility_Functions_Section_Polytopes">
<Heading>Polytopes</Heading>

<ManSection>
  <Func Arg="args" Name="AbstractPolytope" />
 <Description>
Calls <Code>Maniplex(args)</Code> and verifies whether the output is polytopal.
 If not, this throws an error. Use <Code>AbstractPolytopeNC</Code> to assume that the output
 is polytopal and mark it as such.
 </Description>
</ManSection>


<Example><![CDATA[
gap> AbstractPolytope(Group([ (1,2)(3,4)(5,6)(7,8)(9,10), (1,10)(2,3)(4,5)(6,7)(8,9) ]));
Pgon(5)
]]></Example>


<ManSection>
  <Func Arg="args" Name="AbstractRegularPolytope" />
 <Description>
Calls <Code>ReflexibleManiplex(args)</Code> and verifies whether the output is polytopal.
 If not, this throws an error. Use <Code>AbstractRegularPolytopeNC</Code> to assume that the output
 is polytopal and mark it as such.
 Also available as <Code>ARP(args)</Code> and <Code>ARPNC(args)</Code>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Pgon(5)=AbstractRegularPolytope(Group([(2,3)(4,5),(1,2)(3,4)]));
true
]]></Example>


<ManSection>
  <Func Arg="args" Name="AbstractRotaryPolytope" />
 <Description>
Calls <Code>RotaryManiplex(args)</Code> and verifies whether the output is polytopal.
 If not, this throws an error. Use <Code>AbstractRotaryPolytopeNC</Code> to assume that the output
 is polytopal and mark it as such.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Utility_Functions_Section_Permutations">
<Heading>Permutations</Heading>

<ManSection>
  <Func Arg="perm, k" Name="TranslatePerm" />
 <Description>
 Returns a new permutation obtained from <A>perm</A> by adding k
 to each moved point.
 </Description>
</ManSection>


<Example><![CDATA[
gap> TranslatePerm((1,2,3,4),5);
(6,7,8,9)
]]></Example>


<ManSection>
  <Func Arg="perm, multiplier, offset" Name="MultPerm" />
 <Description>
Multiplies together perm, TranslatePerm(perm, offset), TranslatePerm(perm, offset*2),
 ..., with <A>multiplier</A> terms, and returns the result.
 </Description>
</ManSection>


<Example><![CDATA[
gap> MultPerm((1,2,3)(4,5,6),3,7);
(1,2,3)(4,5,6)(8,9,10)(11,12,13)(15,16,17)(18,19,20)
gap> MultPerm((1,2,3,4),2,4);
(1,2,3,4)(5,6,7,8)
]]></Example>


<ManSection>
  <Func Arg="list1, list2" Name="InvolutionListList" />
 <Returns>involution
</Returns>
 <Description>
Construction the involution (when possible) with entries <Code>(list1[i],list2[i])</Code>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> InvolutionListList([3,4,5],[6,7,8]);
(3,6)(4,7)(5,8)
]]></Example>


<ManSection>
  <Func Arg="perm1, perm2" Name="PermFromRange" />
 <Returns>Permutation
</Returns>
 <Description>
This attempts to construct a permutation that we would
 write as perm1 ... perm2. Probably it is clearest to look at some examples:
<Example><![CDATA[
gap> PermFromRange((1,2), (9,10));
(1,2)(3,4)(5,6)(7,8)(9,10)
gap> PermFromRange((1,3), (13,15));
(1,3)(4,6)(7,9)(10,12)(13,15)
gap> PermFromRange((2,3,4), (8,9,10));
(2,3,4)(5,6,7)(8,9,10)
]]></Example>


 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Utility_Functions_Section_Words_on_relations">
<Heading>Words on relations</Heading>

<ManSection>
  <Func Arg="rels, g" Name="ParseStringCRels" />
 <Returns>a list of relators
</Returns>
 <Description>
This helper function is used in several maniplex constructors.
 Given a string <A>rels</A> that represents relations in an sggi, and an sggi g,
 returns a list of elements in the free group of g represented by <A>rels</A>.
 These can then be used to form a quotient of g.
<Example><![CDATA[
gap> g := AutomorphismGroup(CubicTiling(2));;
gap> rels := "(r0 r1 r2 r1)^6";;
gap> newrels := ParseStringCRels(rels, g);
[ (r0*r1*r2*r1)^6 ]
gap> newrels[1] in FreeGroupOfFpGroup(g);
true
gap> g2 := FactorGroupFpGroupByRels(g, newrels);
<fp group on the generators [ r0, r1, r2 ]>
]]></Example>


 For convenience, you may use z1, z2, etc and h1, h2, etc in relations,
 where zj means r0 (r1 r2)^j (the "j-zigzag" word) and hj means r0 (r1 r2)^j-1 r1
 (the "j-hole" word).
 </Description>
</ManSection>


<ManSection>
  <Func Arg="rels, g" Name="ParseRotGpRels" />
 <Description>
This helper function is used in several maniplex constructors.
 It is analogous to ParseStringCRels, but for rotation groups instead.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="L, x" Name="AddOrAppend" />
 <Description>
Given a list <A>L</A> and an object <A>x</A>, this calls
 Append(L, x) if x is a list; otherwise it calls Add(L, x).
 Note that since strings are internally represented as lists,
 AddOrAppend(L, "foo") will append the characters 'f', 'o', 'o'.
<Example><![CDATA[
gap> L := [1, 2, 3];;
gap> AddOrAppend(L, 4);
gap> L;
[1, 2, 3, 4]
gap> AddOrAppend(L, [5, 6]);
gap> L;
[1, 2, 3, 4, 5, 6];
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Func Arg="posetOp" Name="WrappedPosetOperation" />
 <Description>
Given a poset operation, creates a bare-bones maniplex
 operation that delegates to the poset operation.
<Example><![CDATA[
gap> myjoin := WrappedPosetOperation(JoinProduct);
function( arg... ) ... end
gap> M := myjoin(Pgon(4), Vertex());
3-maniplex
gap> M = Pyramid(4);
true
]]></Example>


 Usually, you will want to eventually create a fuller-featured wrapper
 of the poset operation -- one that can infer more information from its
 arguments. But this method is a good way to quickly test whether a poset
 operation works on maniplexes the way one expects.
 </Description>
</ManSection>


</Section>


</Chapter>

