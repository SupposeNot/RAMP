<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (RAMP) - Chapter 1: Graphs for Maniplexes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X84DE212D847339C0" name="X84DE212D847339C0"></a></p>
<div class="ChapSects"><a href="chap1.html#X84DE212D847339C0">1 <span class="Heading">Graphs for Maniplexes</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7CD3FD9D86C12B44">1.1 <span class="Heading">Graphs for maniplexes functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7FB3733D81739F2C">1.1-1 DirectedGraphFromListOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82810A0A7CF30BB4">1.1-2 GraphFromListOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X86BE61C88420C6F6">1.1-3 UnlabeledFlagGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X791AEF1C7AA7138C">1.1-4 FlagGraphWithLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X809815D08250B57F">1.1-5 LayerGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BB443CD832DAC12">1.1-6 Skeleton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A0FB13C7EF68CBB">1.1-7 Hasse</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X860AACCF860A3F66">1.1-8 QuotientByLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X84FE2C317CFA6AFD">1.1-9 EdgeLabeledGraphFromEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A958E7C821DD8F8">1.1-10 FlagGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82A8C3AD871EC6D7">1.1-11 UnlabeledSimpleGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X84263C6C81AB458C">1.1-12 EdgeLabelPreservingAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7D7BF5608431FED8">1.1-13 Simple</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8159C96B8757873F">1.1-14 ConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A53CE8B820FD6A1">1.1-15 PRGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X85BBB22F8196DC0B">1.1-16 CPRGraphFromGroups</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Graphs for Maniplexes</span></h3>

<p><a id="X7CD3FD9D86C12B44" name="X7CD3FD9D86C12B44"></a></p>

<h4>1.1 <span class="Heading">Graphs for maniplexes functions</span></h4>

<p><a id="X7FB3733D81739F2C" name="X7FB3733D81739F2C"></a></p>

<h5>1.1-1 DirectedGraphFromListOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectedGraphFromListOfEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns a directed graph.</p>

<p>Given a list of vertices and a list of directed-edges (represented as ordered pairs), this outputs the directed graph with the appropriate vertex and directed-edge set.</p>

<p>Here we have a directed cycle on 3 vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DirectedGraphFromListOfEdges([1,2,3],[[1,2],[2,3],[3,1]]);</span>
rec( adjacencies := [ [ 2 ], [ 3 ], [ 1 ] ], group := Group(()), 
 isGraph := true, names := [ 1, 2, 3 ], order := 3, 
 representatives := [ 1, 2, 3 ], schreierVector := [ -1, -2, -3 ] )
</pre></div>

<p><a id="X82810A0A7CF30BB4" name="X82810A0A7CF30BB4"></a></p>

<h5>1.1-2 GraphFromListOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphFromListOfEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a list of vertices and a list of (directed) edges (represented as ordered pairs), this outputs the simple underlying graph with the appropriate vertex and directed-edge set.</p>

<p>Here we have a simple complete graph on 4 vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GraphFromListOfEdges([1,2,3,4],[[1,2],[2,3],[3,1], [1,4], [2,4], [3,4]]);</span>
rec( 
 adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ],
 group := Group(()), isGraph := true, isSimple := true, 
 names := [ 1, 2, 3, 4 ], order := 4, representatives := [ 1, 2, 3, 4 ]
   , schreierVector := [ -1, -2, -3, -4 ] )
</pre></div>

<p><a id="X86BE61C88420C6F6" name="X86BE61C88420C6F6"></a></p>

<h5>1.1-3 UnlabeledFlagGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnlabeledFlagGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a group (assumed to be the connection group of a maniplex), this outputs the simple underlying flag graph.</p>

<p>Here we build the flag graph for the cube from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnlabeledFlagGraph(ConnectionGroup(Cube(3)));</span>
rec( 
 adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
     [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
     [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
     [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
     [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], [ 17, 22, 24 ], 
     [ 1, 10, 38 ], [ 18, 32, 40 ], [ 19, 41, 48 ], [ 11, 35, 44 ], 
     [ 12, 19, 34 ], [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], 
     [ 5, 9, 16 ], [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
     [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
     [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], [ 29, 31, 46 ], 
     [ 16, 21, 42 ], [ 6, 22, 29 ], [ 26, 40, 43 ], [ 36, 38, 42 ], 
     [ 14, 23, 46 ], [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
     [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 48 ], order := 48, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
     31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 
     47, 48 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, 
     -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, 
     -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48 ] )
</pre></div>

<p>This also works with a maniplex input. Here we build the flag graph for the cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnlabeledFlagGraph(Cube(3));</span>
</pre></div>

<p><a id="X791AEF1C7AA7138C" name="X791AEF1C7AA7138C"></a></p>

<h5>1.1-4 FlagGraphWithLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagGraphWithLabels</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a triple [<code class="code">IsGraph</code>, <code class="code">IsList</code>, <code class="code">IsList</code>].</p>

<p>Given a group (assumed to be the connection group of a maniplex), this outputs a triple [graph,list,list]. The graph is the unlabeled flag graph of the connection group. The first list gives the undirected edges in the flag graphs. The second list gives the labels for these edges.</p>

<p>Here we again build the flag graph for the cube from its connection group, but this time keep track of labels of the edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= FlagGraphWithLabels(ConnectionGroup(Cube(3)));</span>
[ rec( 
     adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
         [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
         [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
         [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
         [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], 
         [ 17, 22, 24 ], [ 1, 10, 38 ], [ 18, 32, 40 ], 
         [ 19, 41, 48 ], [ 11, 35, 44 ], [ 12, 19, 34 ], 
         [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], [ 5, 9, 16 ], 
         [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
         [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
         [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], 
         [ 29, 31, 46 ], [ 16, 21, 42 ], [ 6, 22, 29 ], 
         [ 26, 40, 43 ], [ 36, 38, 42 ], [ 14, 23, 46 ], 
         [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
         [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
     isSimple := true, names := [ 1 .. 48 ], order := 48, 
     representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 
         14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 
         29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 
         44, 45, 46, 47, 48 ], 
     schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
         -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, 
         -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, 
         -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, 
         -48 ] ), 
 [ [ 1, 3 ], [ 1, 11 ], [ 1, 20 ], [ 2, 7 ], [ 2, 13 ], [ 2, 18 ], 
     [ 3, 4 ], [ 3, 10 ], [ 4, 25 ], [ 4, 34 ], [ 5, 26 ], [ 5, 28 ], 
     [ 5, 35 ], [ 6, 7 ], [ 6, 13 ], [ 6, 41 ], [ 7, 8 ], [ 8, 27 ], 
     [ 8, 32 ], [ 9, 28 ], [ 9, 33 ], [ 9, 35 ], [ 10, 20 ], 
     [ 10, 45 ], [ 11, 14 ], [ 11, 23 ], [ 12, 15 ], [ 12, 17 ], 
     [ 12, 24 ], [ 13, 31 ], [ 14, 25 ], [ 14, 44 ], [ 15, 45 ], 
     [ 15, 47 ], [ 16, 18 ], [ 16, 28 ], [ 16, 40 ], [ 17, 19 ], 
     [ 17, 27 ], [ 18, 21 ], [ 19, 22 ], [ 19, 24 ], [ 20, 38 ], 
     [ 21, 32 ], [ 21, 40 ], [ 22, 41 ], [ 22, 48 ], [ 23, 35 ], 
     [ 23, 44 ], [ 24, 34 ], [ 25, 37 ], [ 26, 38 ], [ 26, 42 ], 
     [ 27, 30 ], [ 29, 39 ], [ 29, 41 ], [ 29, 48 ], [ 30, 32 ], 
     [ 30, 47 ], [ 31, 33 ], [ 31, 39 ], [ 33, 46 ], [ 34, 37 ], 
     [ 36, 43 ], [ 36, 45 ], [ 36, 47 ], [ 37, 48 ], [ 38, 43 ], 
     [ 39, 46 ], [ 40, 42 ], [ 42, 43 ], [ 44, 46 ] ], 
 [ 3, 2, 1, 3, 1, 2, 2, 1, 3, 1, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 2, 3, 
     3, 2, 3, 1, 2, 3, 1, 2, 2, 1, 1, 3, 1, 2, 3, 1, 2, 3, 2, 3, 2, 2, 
     1, 1, 3, 2, 3, 2, 1, 1, 3, 3, 2, 3, 1, 1, 2, 1, 3, 3, 3, 2, 3, 1, 
     2, 3, 1, 2, 1, 2 ] ]
</pre></div>

<p>This also works with a maniplex input. Here we build the flag graph for the cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= FlagGraphWithLabels(Cube(3));</span>
</pre></div>

<p><a id="X809815D08250B57F" name="X809815D08250B57F"></a></p>

<h5>1.1-5 LayerGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LayerGraph</code>( [<var class="Arg">group</var>, <var class="Arg">int</var>, <var class="Arg">int</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a group (assumed to be the connection group of a maniplex), and two integers, this outputs the simple underlying graph given by incidences of faces of those ranks. Note: There are no warnings yet to make sure that i,j are bounded by the rank.</p>

<p>Here we build the graph given by the 6 faces and 12 edges of a cube from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LayerGraph(ConnectionGroup(Cube(3)),2,1);</span>
rec( 
 adjacencies := [ [ 7, 10, 12, 17 ], [ 8, 10, 15, 18 ], 
     [ 7, 9, 13, 14 ], [ 8, 11, 13, 16 ], [ 9, 12, 16, 18 ], 
     [ 11, 14, 15, 17 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 2 ], 
     [ 4, 6 ], [ 1, 5 ], [ 3, 4 ], [ 3, 6 ], [ 2, 6 ], [ 4, 5 ], 
     [ 1, 6 ], [ 2, 5 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 18 ], order := 18, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18 ] )
</pre></div>

<p>This also works with a maniplex input. Here we build the graph given by the 6 faces and 12 edges of a cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LayerGraph(Cube(3),2,1);;</span>
</pre></div>

<p><a id="X7BB443CD832DAC12" name="X7BB443CD832DAC12"></a></p>

<h5>1.1-6 Skeleton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Skeleton</code>( <var class="Arg">maniplex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a maniplex, this outputs the 0-1 skeleton. The vertices are the 0-faces, and the edges are the 1-faces.</p>

<p>Here we build the skeleton of the dodecahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Skeleton(Dodecahedron());;</span>
</pre></div>

<p><a id="X7A0FB13C7EF68CBB" name="X7A0FB13C7EF68CBB"></a></p>

<h5>1.1-7 Hasse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Hasse</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns a directed graph.</p>

<p>Given a group, assumed to be the connection group of a maniplex, this outputs the Hasse Diagram as a directed graph. Note: The unique minimal and maximal face are assumed.</p>

<p>Here we build the Hasse Diagram of a 3-simplex from its representation as a maniplex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hasse(Simplex(3));</span>
rec( 
 adjacencies := [ [  ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 2, 4 ], 
     [ 2, 3 ], [ 3, 5 ], [ 2, 5 ], [ 4, 5 ], [ 3, 4 ], [ 6, 9, 10 ], 
     [ 6, 7, 11 ], [ 8, 10, 11 ], [ 7, 8, 9 ], [ 12, 13, 14, 15 ] ], 
 group := Group(()), isGraph := true, names := [ 1 .. 16 ], 
 order := 16, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16 ] )
</pre></div>

<p><a id="X860AACCF860A3F66" name="X860AACCF860A3F66"></a></p>

<h5>1.1-8 QuotientByLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuotientByLabel</code>( <var class="Arg">object</var>, <var class="Arg">list</var>, <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a graph, its edges, and its edge labels, and a sublist of labels, this creates the underlying simple graph of the quotient identifying vertices connected by labels not in the sublist.</p>

<p>Here we start with the flag graph of the 3-cube (with edge labels 1,2,3), and identify any vertices not connected by edge by edges of label 1. We can then check that this new graph is bipartite.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=Cube(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=FlagGraphWithLabels(P);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=f[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ed:=f[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lab:=f[3];  #Note This triple is to be replace by a single object.</span>
[ 3, 2, 1, 3, 1, 2, 1, 2, 3, 2, 1, 3, 2, 1, 1, 3, 2, 2, 3, 1, 3, 1, 2, 3, 2, 1, 1, 2, 2, 3, 1, 3, 1, 2, 
  3, 1, 2, 1, 3, 2, 2, 1, 2, 2, 3, 1, 1, 3, 1, 3, 3, 2, 1, 2, 1, 3, 3, 1, 3, 2, 2, 2, 2, 3, 3, 1, 3, 1, 1, 3, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q:=QuotientByLabel(g,ed,lab,[1]);</span>
rec( adjacencies := [ [ 5, 6, 8 ], [ 3, 4, 7 ], [ 2, 6, 8 ], [ 2, 5, 8 ], [ 1, 4, 7 ], [ 1, 3, 7 ], [ 2, 5, 6 ], [ 1, 3, 4 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 8 ], order := 8, representatives := [ 1, 2, 3, 4, 5, 6, 7, 8 ], schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBipartite(Q);</span>
true
</pre></div>

<p><a id="X84FE2C317CFA6AFD" name="X84FE2C317CFA6AFD"></a></p>

<h5>1.1-9 EdgeLabeledGraphFromEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeLabeledGraphFromEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given a list of vertices, a list of edges, and a list of edge labels, this represents the edge labeled (multi)-graph with those parameters. Semi-edges are represented by a singleton in the edge list. Loops are represented by edges [i,i]</p>

<p>Here we have an edge labeled cycle graph with 6 vertices and edges alternating in labels 0,1.</p>


<div class="example"><pre>
V:=[1..6];;
Edges:=[[1,2],[2,3],[3,4],[4,5],[5,6],[6,1]];;
L:=[0,1,0,1,0,1];;
gamma:=EdgeLabeledGraphFromEdges(V,Edges,L);
</pre></div>

<p><a id="X7A958E7C821DD8F8" name="X7A958E7C821DD8F8"></a></p>

<h5>1.1-10 FlagGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given group, assumed to be a connection group, output the labeled flag graph. The input could also be a maniplex, then the connection group is calculated.</p>

<p>Here we have the flag graph of the 3-simplex from its connection group.</p>


<div class="example"><pre>
C:=ConnectionGroup(Simplex(3));;
gamma:=FlagGraph(C);
</pre></div>

<p><a id="X82A8C3AD871EC6D7" name="X82A8C3AD871EC6D7"></a></p>

<h5>1.1-11 UnlabeledSimpleGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnlabeledSimpleGraph</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>.</p>

<p>Given an edge labeled (multi) graph, it returns the underlying simple graph, with semi-edges, loops, and muliple-edges removed.</p>

<p>Here we have underlying simple graph for the flag graph of the cube.</p>


<div class="example"><pre>
gamma:=UnlabeledSimpleGraph(FlagGraph(Cube(3)));
</pre></div>

<p><a id="X84263C6C81AB458C" name="X84263C6C81AB458C"></a></p>

<h5>1.1-12 EdgeLabelPreservingAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeLabelPreservingAutomorphismGroup</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGroup</code>.</p>

<p>Given an edge labeled (multi) graph, it returns automorphism group (preserving the labels). Note, for now the labels are assumed to be [1..n]. Note This tends to be very slow. I would like to look for a way to go back and forth between flag automorphisms and poset automorphisms, as the latter are much faster to compute.</p>

<p>Here we have the automorphism group of the flag graph of the cube.</p>


<div class="example"><pre>
g:=EdgeLabelPreservingAutomorphismGroup(FlagGraph(Cube(3)));;
Size(g);
</pre></div>

<p><a id="X7D7BF5608431FED8" name="X7D7BF5608431FED8"></a></p>

<h5>1.1-13 Simple</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Simple</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph </code>.</p>

<p>Given an edge labeled (multi) graph, it returns another edge labeled graph where semi-edges, loops, and multiple edges are removed. Note only the "first" edge label is retained if there are multiple edges.</p>

<p><a id="X8159C96B8757873F" name="X8159C96B8757873F"></a></p>

<h5>1.1-14 ConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConnectedComponents</code>( <var class="Arg">edge-labeled-graph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>.</p>

<p>Given an edge labeled (multi) graph and a list of labels, it returns connected components of the graph using edges in the list of labels. Note if the second argument is not used, it is assumed to be an empty list, and the connected components of the original graph are returned.</p>

<p>Here we see that each connected component of the flag graph of the cube (which has labels 1,2,3) where edges of label 2 are removed, is a 4 cycle.</p>


<div class="example"><pre>
gamma:=ConnectedComponents(FlagGraph(Cube(3)),[2]);
</pre></div>

<p><a id="X7A53CE8B820FD6A1" name="X7A53CE8B820FD6A1"></a></p>

<h5>1.1-15 PRGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PRGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph </code>.</p>

<p>Given a group, it returns the permutation representation graph for that group. When the group is a string C-group this is also called a CPR graph. The labels of the edges are [1...r] where r is the number of generators of the group.</p>

<p>Here we see the CPR graph of the automorphism group of a cube (acting on its 8 vertices).</p>


<div class="example"><pre>
G:=AutomorphismGroup(Cube(3));
H:=Group(G.2,G.3);
phi:=FactorCosetAction(G,H);
G2:=Range(phi);
gamma:=PRGraph(G2);
</pre></div>

<p><a id="X85BBB22F8196DC0B" name="X85BBB22F8196DC0B"></a></p>

<h5>1.1-16 CPRGraphFromGroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CPRGraphFromGroups</code>( <var class="Arg">group</var>, <var class="Arg">subgroup</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsEdgeLabeledGraph</code>.</p>

<p>Given a group and a subgroup. Returns the graph of the action of the first group on cosets of the subgroup.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
