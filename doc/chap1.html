<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (RAMP) - Chapter 1: Graphs for Maniplexes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X84DE212D847339C0" name="X84DE212D847339C0"></a></p>
<div class="ChapSects"><a href="chap1.html#X84DE212D847339C0">1 <span class="Heading">Graphs for Maniplexes</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7CD3FD9D86C12B44">1.1 <span class="Heading">Graphs for maniplexes functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7FB3733D81739F2C">1.1-1 DirectedGraphFromListOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82810A0A7CF30BB4">1.1-2 GraphFromListOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X86BE61C88420C6F6">1.1-3 UnlabeledFlagGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X791AEF1C7AA7138C">1.1-4 FlagGraphWithLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X809815D08250B57F">1.1-5 LayerGraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BB443CD832DAC12">1.1-6 Skeleton</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A0FB13C7EF68CBB">1.1-7 Hasse</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Graphs for Maniplexes</span></h3>

<p><a id="X7CD3FD9D86C12B44" name="X7CD3FD9D86C12B44"></a></p>

<h4>1.1 <span class="Heading">Graphs for maniplexes functions</span></h4>

<p><a id="X7FB3733D81739F2C" name="X7FB3733D81739F2C"></a></p>

<h5>1.1-1 DirectedGraphFromListOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectedGraphFromListOfEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns a directed graph.</p>

<p>Given a list of vertices and a list of directed-edges (represented as ordered pairs), this outputs the directed graph with the appropriate vertex and directed-edge set.</p>

<p>Here we have a directed cycle on 3 vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DirectedGraphFromListOfEdges([1,2,3],[[1,2],[2,3],[3,1]]);</span>
rec( adjacencies := [ [ 2 ], [ 3 ], [ 1 ] ], group := Group(()), 
 isGraph := true, names := [ 1, 2, 3 ], order := 3, 
 representatives := [ 1, 2, 3 ], schreierVector := [ -1, -2, -3 ] )
</pre></div>

<p><a id="X82810A0A7CF30BB4" name="X82810A0A7CF30BB4"></a></p>

<h5>1.1-2 GraphFromListOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GraphFromListOfEdges</code>( <var class="Arg">list</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a list of vertices and a list of (directed) edges (represented as ordered pairs), this outputs the simple underlying graph with the appropriate vertex and directed-edge set.</p>

<p>Here we have a simple complete graph on 4 vertices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GraphFromListOfEdges([1,2,3,4],[[1,2],[2,3],[3,1], [1,4], [2,4], [3,4]]);</span>
rec( 
 adjacencies := [ [ 2, 3, 4 ], [ 1, 3, 4 ], [ 1, 2, 4 ], [ 1, 2, 3 ] ],
 group := Group(()), isGraph := true, isSimple := true, 
 names := [ 1, 2, 3, 4 ], order := 4, representatives := [ 1, 2, 3, 4 ]
   , schreierVector := [ -1, -2, -3, -4 ] )
</pre></div>

<p><a id="X86BE61C88420C6F6" name="X86BE61C88420C6F6"></a></p>

<h5>1.1-3 UnlabeledFlagGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnlabeledFlagGraph</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a group (assumed to be the connection group of a maniplex), this outputs the simple underlying flag graph.</p>

<p>Here we build the flag graph for the cube from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnlabeledFlagGraph(ConnectionGroup(Cube(3)));</span>
rec( 
 adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
     [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
     [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
     [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
     [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], [ 17, 22, 24 ], 
     [ 1, 10, 38 ], [ 18, 32, 40 ], [ 19, 41, 48 ], [ 11, 35, 44 ], 
     [ 12, 19, 34 ], [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], 
     [ 5, 9, 16 ], [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
     [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
     [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], [ 29, 31, 46 ], 
     [ 16, 21, 42 ], [ 6, 22, 29 ], [ 26, 40, 43 ], [ 36, 38, 42 ], 
     [ 14, 23, 46 ], [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
     [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 48 ], order := 48, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
     31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 
     47, 48 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, 
     -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, 
     -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48 ] )
</pre></div>

<p>This also works with a maniplex input. Here we build the flag graph for the cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnlabeledFlagGraph(Cube(3));</span>
</pre></div>

<p><a id="X791AEF1C7AA7138C" name="X791AEF1C7AA7138C"></a></p>

<h5>1.1-4 FlagGraphWithLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FlagGraphWithLabels</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a triple [<code class="code">IsGraph</code>, <code class="code">IsList</code>, <code class="code">IsList</code>].</p>

<p>Given a group (assumed to be the connection group of a maniplex), this outputs a triple [graph,list,list]. The graph is the unlabeled flag graph of the connection group. The first list gives the undirected edges in the flag graphs. The second list gives the labels for these edges.</p>

<p>Here we again build the flag graph for the cube from its connection group, but this time keep track of labels of the edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= FlagGraphWithLabels(ConnectionGroup(Cube(3)));</span>
[ rec( 
     adjacencies := [ [ 3, 11, 20 ], [ 7, 13, 18 ], [ 1, 4, 10 ], 
         [ 3, 25, 34 ], [ 26, 28, 35 ], [ 7, 13, 41 ], [ 2, 6, 8 ], 
         [ 7, 27, 32 ], [ 28, 33, 35 ], [ 3, 20, 45 ], [ 1, 14, 23 ], 
         [ 15, 17, 24 ], [ 2, 6, 31 ], [ 11, 25, 44 ], [ 12, 45, 47 ], 
         [ 18, 28, 40 ], [ 12, 19, 27 ], [ 2, 16, 21 ], 
         [ 17, 22, 24 ], [ 1, 10, 38 ], [ 18, 32, 40 ], 
         [ 19, 41, 48 ], [ 11, 35, 44 ], [ 12, 19, 34 ], 
         [ 4, 14, 37 ], [ 5, 38, 42 ], [ 8, 17, 30 ], [ 5, 9, 16 ], 
         [ 39, 41, 48 ], [ 27, 32, 47 ], [ 13, 33, 39 ], 
         [ 8, 21, 30 ], [ 9, 31, 46 ], [ 4, 24, 37 ], [ 5, 9, 23 ], 
         [ 43, 45, 47 ], [ 25, 34, 48 ], [ 20, 26, 43 ], 
         [ 29, 31, 46 ], [ 16, 21, 42 ], [ 6, 22, 29 ], 
         [ 26, 40, 43 ], [ 36, 38, 42 ], [ 14, 23, 46 ], 
         [ 10, 15, 36 ], [ 33, 39, 44 ], [ 15, 30, 36 ], 
         [ 22, 29, 37 ] ], group := Group(()), isGraph := true, 
     isSimple := true, names := [ 1 .. 48 ], order := 48, 
     representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 
         14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 
         29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 
         44, 45, 46, 47, 48 ], 
     schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
         -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, 
         -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, 
         -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, 
         -48 ] ), 
 [ [ 1, 3 ], [ 1, 11 ], [ 1, 20 ], [ 2, 7 ], [ 2, 13 ], [ 2, 18 ], 
     [ 3, 4 ], [ 3, 10 ], [ 4, 25 ], [ 4, 34 ], [ 5, 26 ], [ 5, 28 ], 
     [ 5, 35 ], [ 6, 7 ], [ 6, 13 ], [ 6, 41 ], [ 7, 8 ], [ 8, 27 ], 
     [ 8, 32 ], [ 9, 28 ], [ 9, 33 ], [ 9, 35 ], [ 10, 20 ], 
     [ 10, 45 ], [ 11, 14 ], [ 11, 23 ], [ 12, 15 ], [ 12, 17 ], 
     [ 12, 24 ], [ 13, 31 ], [ 14, 25 ], [ 14, 44 ], [ 15, 45 ], 
     [ 15, 47 ], [ 16, 18 ], [ 16, 28 ], [ 16, 40 ], [ 17, 19 ], 
     [ 17, 27 ], [ 18, 21 ], [ 19, 22 ], [ 19, 24 ], [ 20, 38 ], 
     [ 21, 32 ], [ 21, 40 ], [ 22, 41 ], [ 22, 48 ], [ 23, 35 ], 
     [ 23, 44 ], [ 24, 34 ], [ 25, 37 ], [ 26, 38 ], [ 26, 42 ], 
     [ 27, 30 ], [ 29, 39 ], [ 29, 41 ], [ 29, 48 ], [ 30, 32 ], 
     [ 30, 47 ], [ 31, 33 ], [ 31, 39 ], [ 33, 46 ], [ 34, 37 ], 
     [ 36, 43 ], [ 36, 45 ], [ 36, 47 ], [ 37, 48 ], [ 38, 43 ], 
     [ 39, 46 ], [ 40, 42 ], [ 42, 43 ], [ 44, 46 ] ], 
 [ 3, 2, 1, 3, 1, 2, 2, 1, 3, 1, 2, 3, 1, 1, 3, 2, 2, 1, 3, 1, 2, 3, 
     3, 2, 3, 1, 2, 3, 1, 2, 2, 1, 1, 3, 1, 2, 3, 1, 2, 3, 2, 3, 2, 2, 
     1, 1, 3, 2, 3, 2, 1, 1, 3, 3, 2, 3, 1, 1, 2, 1, 3, 3, 3, 2, 3, 1, 
     2, 3, 1, 2, 1, 2 ] ]
</pre></div>

<p>This also works with a maniplex input. Here we build the flag graph for the cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= FlagGraphWithLabels(Cube(3));</span>
</pre></div>

<p><a id="X809815D08250B57F" name="X809815D08250B57F"></a></p>

<h5>1.1-5 LayerGraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LayerGraph</code>( [<var class="Arg">group</var>, <var class="Arg">int</var>, <var class="Arg">int</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a group (assumed to be the connection group of a maniplex), and two integers, this outputs the simple underlying graph given by incidences of faces of those ranks. Note: There are no warnings yet to make sure that i,j are bounded by the rank.</p>

<p>Here we build the graph given by the 6 faces and 12 edges of a cube from its connection group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LayerGraph(ConnectionGroup(Cube(3)),2,1);</span>
rec( 
 adjacencies := [ [ 7, 10, 12, 17 ], [ 8, 10, 15, 18 ], 
     [ 7, 9, 13, 14 ], [ 8, 11, 13, 16 ], [ 9, 12, 16, 18 ], 
     [ 11, 14, 15, 17 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 2 ], 
     [ 4, 6 ], [ 1, 5 ], [ 3, 4 ], [ 3, 6 ], [ 2, 6 ], [ 4, 5 ], 
     [ 1, 6 ], [ 2, 5 ] ], group := Group(()), isGraph := true, 
 isSimple := true, names := [ 1 .. 18 ], order := 18, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16, 17, 18 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16, -17, -18 ] )
</pre></div>

<p>This also works with a maniplex input. Here we build the graph given by the 6 faces and 12 edges of a cube.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= LayerGraph(Cube(3),2,1);;</span>
</pre></div>

<p><a id="X7BB443CD832DAC12" name="X7BB443CD832DAC12"></a></p>

<h5>1.1-6 Skeleton</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Skeleton</code>( <var class="Arg">maniplex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns an undirected graph.</p>

<p>Given a maniplex, this outputs the 0-1 skeleton. The vertices are the 0-faces, and the edges are the 1-faces.</p>

<p>Here we build the skeleton of the dodecahedron.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Skeleton(Dodecahedron());;</span>
</pre></div>

<p><a id="X7A0FB13C7EF68CBB" name="X7A0FB13C7EF68CBB"></a></p>

<h5>1.1-7 Hasse</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Hasse</code>( <var class="Arg">group</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">IsGraph</code>. Note this returns a directed graph.</p>

<p>Given a group, assumed to be the connection group of a maniplex, this outputs the Hasse Diagram as a directed graph. Note: The unique minimal and maximal face are assumed.</p>

<p>Here we build the Hasse Diagram of a 3-simplex from its representation as a maniplex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hasse(Simplex(3));</span>
rec( 
 adjacencies := [ [  ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 2, 4 ], 
     [ 2, 3 ], [ 3, 5 ], [ 2, 5 ], [ 4, 5 ], [ 3, 4 ], [ 6, 9, 10 ], 
     [ 6, 7, 11 ], [ 8, 10, 11 ], [ 7, 8, 9 ], [ 12, 13, 14, 15 ] ], 
 group := Group(()), isGraph := true, names := [ 1 .. 16 ], 
 order := 16, 
 representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
     15, 16 ], 
 schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, 
     -12, -13, -14, -15, -16 ] )
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
