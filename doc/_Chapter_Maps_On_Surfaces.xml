<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Maps_On_Surfaces">
<Heading>Maps On Surfaces</Heading>

<Section Label="Chapter_Maps_On_Surfaces_Section_Bicontactual_regular_maps">
<Heading>Bicontactual regular maps</Heading>

 The names for the maps in this section are from S.E. Wilson's <Cite Key="Wil85"/>. 
<ManSection>
  <Oper Arg="k" Name="Epsilonk" Label="for IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given an integer <A>k</A>, gives the map <Math>\epsilon_k</Math>, which is <Math>\{k,2\}_k</Math> when <A>k</A> is even, and <Math>\{k,2\}_{2k}</Math> when <A>k</A> is odd.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Epsilonk(5);
AbstractRegularPolytope([ 5, 2 ])
gap> Epsilonk(6);
AbstractRegularPolytope([ 6, 2 ])
]]></Example>


<ManSection>
  <Oper Arg="k" Name="Deltak" Label="for IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given an integer <A>k</A>, gives the map <Math>\delta_k</Math>, which is <Math>\{2k,2\}/2</Math> when <A>k</A> is even, and <Math>\{2k,2\}_{k}</Math> when <A>k</A> is odd.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Deltak(5);
AbstractRegularPolytope([ 10, 2 ], "(r0 r1)^5 r2")
gap> Deltak(6);
AbstractRegularPolytope([ 12, 2 ], "(r0 r1)^6 r2")
]]></Example>


<ManSection>
  <Oper Arg="k" Name="Mk" Label="for IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given an integer <A>k</A>, gives the map <Math>M_k</Math>, which is <Math>\{2k,2k\}_{1,0}</Math> when <A>k</A> is even, and <Math>\{2k,k\}_{2}</Math> when <A>k</A> is odd.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Mk(5);Mk(6);
AbstractRegularPolytope([ 10, 5 ], "(r0 r1)^5 r0 = r2")
AbstractRegularPolytope([ 12, 12 ], "(r0 r1)^6 r0 = r2")
]]></Example>


<ManSection>
  <Oper Arg="k" Name="MkPrime" Label="for IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given an integer <A>k</A>, gives the map <Math>M'_k</Math>, which is <Math>\{k,k\}_2</Math> when <A>k</A> is even, and <Math>\{k,2k\}_{2}</Math> when <A>k</A> is odd.
 <Code>MkPrime(k,i)</Code> gives the map <Math>M'_{k,i}</Math>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> MkPrime(5);MkPrime(6);
ReflexibleManiplex([ 5, 10 ], "(r2*r1*(r0 r2))^5,z1^2")
ReflexibleManiplex([ 6, 6 ], "(r2*r1*(r0 r2))^6,z1^2")
]]></Example>


<ManSection>
  <Oper Arg="k, l" Name="Bk2l" Label="for IsInt,IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given integers <A>k,l</A>, gives the map <Math>B(k,2l)</Math>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Bk2l(4,5);
3-maniplex with 80 flags
]]></Example>


<ManSection>
  <Oper Arg="k, l" Name="Bk2lStar" Label="for IsInt,IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given integers <A>k,l</A>, gives the map <Math>B^*(k,2l)</Math>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Bk2lStar(5,7);
3-maniplex with 140 flags
]]></Example>


</Section>


<Section Label="Chapter_Maps_On_Surfaces_Section_Operations_on_reflexible_maps">
<Heading>Operations on reflexible maps</Heading>

<ManSection>
  <Oper Arg="map" Name="Opp" Label="for IsManiplex"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Forms the opposite map of the maniplex <A>map</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Opp(Bk2lStar(5,7));
Petrial(Dual(Petrial(3-maniplex with 140 flags)))
]]></Example>


<ManSection>
  <Oper Arg="map, j" Name="Hole" Label="for IsManiplex,IsInt"/>
 <Returns>IsManiplex
</Returns>
 <Description>
Given <A>map</A> and integer <Math>j</Math>, will form the map <Math>H_j(map)</Math>. Note that if the action of <Math>[r_0,(r_1 r_2)^{j-1} r_1, r_2]</Math> on the flags forms multiple orbits, then the resulting map will be on just one of those orbits.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Hole(Bk2lStar(5,7),2);
3-maniplex with 140 flags
]]></Example>


</Section>


<Section Label="Chapter_Maps_On_Surfaces_Section_Map_properties">
<Heading>Map properties</Heading>

<ManSection>
  <Attr Arg="M" Name="IsMapOnSurface" Label="for IsManiplex"/>
 <Returns>IsBool
</Returns>
 <Description>
Determines whether a given maniplex is a map on a surface
 </Description>
</ManSection>


<Example><![CDATA[
gap> Filtered([HemiCube(3),Cube(4),Icosahedron()],IsMapOnSurface);
[ HemiCube(3), Icosahedron() ]
]]></Example>


</Section>


<Section Label="Chapter_Maps_On_Surfaces_Section_Operations_on_maps">
<Heading>Operations on maps</Heading>

<ManSection>
  <Oper Arg="map" Name="MapTruncation" Label="for IsManiplex"/>
 <Returns>trunc_map
</Returns>
 <Description>
Given a <A>map</A> on a surface, this function will return the truncation of <A>map</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> SchlafliSymbol(MapTruncation(Simplex(3)));
[ [ 3, 6 ], 3 ]
]]></Example>


</Section>


</Chapter>

